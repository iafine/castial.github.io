<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Hyyy的技术博客</title><meta name="description" content="A Blog Powered By Hexo"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="Hyyy的技术博客"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link active">博客</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">归档</a></li><li class="nav-list-item"><a href="http://www.jianshu.com/u/eee3fae14bec" target="_blank" class="nav-list-link">简书</a></li><li class="nav-list-item"><a href="https://github.com/castial" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><ul class="home post-list"><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/06/18/iOS小结之多线程/" class="post-title-link">iOS小结之多线程</a></h2><div class="post-info">Jun 18, 2017</div><div class="post-content"><blockquote>
<p>小结第三篇，来总结总结iOS中多线程操作。</p>
</blockquote>
<h3 id="多线程概述"><a href="#多线程概述" class="headerlink" title="多线程概述"></a>多线程概述</h3><p>对于ios系统中的某个App来讲，是单进程多线程方式来工作。一般来说，使用多线程的好处是可以把程序分成相对独立的几个模块，可以有效的防止某个模块堵塞的时候导致整个程序卡死；还有就是提高运行效率，现在CPU都是多核，多个核可以同时跑，可以同时执行多条线程。</p>
<p>谈细节之前里，我们得说下有关多线程的几个概念。</p>
<h4 id="串行和并发"><a href="#串行和并发" class="headerlink" title="串行和并发"></a>串行和并发</h4><p>串行的意思是在多个任务下，每次只会有一个任务被执行，并发的意思是同一时间多个任务同时发生。并发是一种现象，解决并发现象的技术，叫做并行。我们经常说的多线程编程，说的就是并行技术，可以让多个CPU同时执行，加快执行速度，提高执行效率。</p>
<h4 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h4><p>同步的意思是在多任务中，一个任务只能等待另一个任务完成之后，他才可以进行，而异步的意思是一个任务的执行，不需要等待上一个任务的执行，不会发生堵塞。</p>
<h4 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h4><p>临界区是一种资源，这块资源不能并发执行，就叫做临界区。我们一般所看到的，临界区就是一个代码块。因为临界区资源如果可以被多个线程同时进行操作，比如读写，就可能出现异常。</p>
<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>死锁就是指两条线程互相都在等待对方执行完毕，才能进入下一步操作。由于两条线程都不能执行下一步，所以造成死锁，卡住不动了。</p>
<h4 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h4><p>线程安全在iOS开发中应该听到多很多次，指的是在多线程中或者并发任务中可以被安全地调用，就称为线程安全。比如<code>NSDictionary</code>就是线程安全的，可以在多线程中使用它，不会出现问题，而<code>NSMutableDictionary</code>是线程不安全的，所以使用<code>NSMutableDictionary</code>的时候应该保证每次只能有一个线程访问它。</p>
<h4 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h4><p>上下文切换指的是在一条进程中切换不同线程时，线程的等待和恢复执行的过程。这一过程中会带来一些额外的开销。</p></div><a href="/2017/06/18/iOS小结之多线程/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/06/11/iOS小结之Runloop/" class="post-title-link">iOS小结之Runloop</a></h2><div class="post-info">Jun 11, 2017</div><div class="post-content"><blockquote>
<p>小结第二篇，来总结下Runloop的知识。</p>
</blockquote>
<h3 id="Runloop概述"><a href="#Runloop概述" class="headerlink" title="Runloop概述"></a>Runloop概述</h3><p>学过操作系统的同学都知道，一般来说，一条线程只能执行一个任务，当任务结束后，线程就会退出，完成使命。但是，在很多场景中，我们并不想让线程执行完任务就退出，往往，我们需要其保持随时随地听从命令，可以在需要的时候执行任务，不需要的时候处于等待状态。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function loop() &#123;</div><div class="line">    initLoop();</div><div class="line">    do &#123;</div><div class="line">        if(message_hasTask()) &#123;</div><div class="line">            message_execute(get_current_message());</div><div class="line">        &#125;</div><div class="line">    &#125; while (message != quit);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>比如，在手游上，我们需要一个模型来一直监听用户的触摸事件，来对游戏画面进行切换和逻辑判断。这种模型一般都具有相似性。比如：当模型被事件唤醒之后，如何快速地进行响应；当模型处于等待状态时，如何减少资源耗用等等。</p>
<p>这种模型，在iOS中称作Runloop。Runloop所解决的问题，就是实现一个线程，使得可以随时响应用户的事件，而不退出。</p></div><a href="/2017/06/11/iOS小结之Runloop/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/06/05/iOS小结之copy属性/" class="post-title-link">iOS小结之copy属性</a></h2><div class="post-info">Jun 5, 2017</div><div class="post-content"><blockquote>
<p>一直都想去写个系列出来，总结出自己在日常开发中遇到过的知识点，时不时的回头看看，温故而知新。</p>
</blockquote>
<p>小结第一篇，来总结一下iOS开发中有关copy的知识点。</p>
<h3 id="iOS中，深拷贝和浅拷贝有什么不同？"><a href="#iOS中，深拷贝和浅拷贝有什么不同？" class="headerlink" title="iOS中，深拷贝和浅拷贝有什么不同？"></a>iOS中，深拷贝和浅拷贝有什么不同？</h3><h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h4><p>所谓的浅拷贝，就是指只是将对象内存地址多了一个引用，也就是说，拷贝结束之后，两个对象的值不仅相同，而且对象所指的内存地址都是一样的。</p>
<h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><p>所谓深拷贝，就是指拷贝一个对象的具体内容，拷贝结束之后，两个对象的值虽然是相同的，但是指向的内存地址是不同的。两个对象之间也互不影响，互不干扰。</p>
<h4 id="非集合类对象的copy和mutableCopy"><a href="#非集合类对象的copy和mutableCopy" class="headerlink" title="非集合类对象的copy和mutableCopy"></a>非集合类对象的copy和mutableCopy</h4><p>我们对一个NSString属性进行copy和mutableCopy。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">NSString *string = @&quot;abc&quot;;</div><div class="line">NSString *stringCopy = [string copy];</div><div class="line">NSMutableString *stringMCopy = [string mutableCopy];</div><div class="line"></div><div class="line">NSLog(@&quot;string: %p, %p&quot;, string, &amp;string);</div><div class="line">NSLog(@&quot;stringCopy: %p, %p&quot;, stringCopy, &amp;stringCopy);</div><div class="line">NSLog(@&quot;stringMCopy: %p, %p&quot;, stringMCopy, &amp;stringMCopy);</div></pre></td></tr></table></figure>
<p>运行之后，可以发现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">string: 0x1022fe078, 0x7fff5d901a48</div><div class="line">stringCopy: 0x1022fe078, 0x7fff5d901a40</div><div class="line">stringMCopy: 0x608000260240, 0x7fff5d901a38</div></pre></td></tr></table></figure>
<p>可以看出，对NSString进行copy操作，其新对象的内存地址并没有发生变化，改变的只仅仅是指针的地址，但是进行mutableCopy操作，其内存地址已经发生了变化，并且指针地址发生变化。我们将内存地址发生了变化的copy操作，称之为深拷贝，反之，内存地址没有发生了变化，称之为浅拷贝。</p></div><a href="/2017/06/05/iOS小结之copy属性/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/04/20/iOS中遍历的总结/" class="post-title-link">iOS中遍历的总结</a></h2><div class="post-info">Apr 20, 2017</div><div class="post-content"><h3 id="遍历的种类"><a href="#遍历的种类" class="headerlink" title="遍历的种类"></a>遍历的种类</h3><p>在iOS开发中，可以使用多种方法进行元素遍历，具体有一下几种：</p>
<h4 id="经典for循环"><a href="#经典for循环" class="headerlink" title="经典for循环"></a>经典for循环</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">NSArray *iosArray = @[@&quot;a&quot;, @&quot;b&quot;, @&quot;c&quot;, @&quot;d&quot;, @&quot;e&quot;, @&quot;f&quot;, @&quot;g&quot;];</div><div class="line">for (int i = 0; i &lt; iosArray.count; i++) &#123;</div><div class="line">    //处理数组中数据</div><div class="line">    NSLog(@&quot;%@&quot;, iosArray[i]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="NSEnumerator遍历"><a href="#NSEnumerator遍历" class="headerlink" title="NSEnumerator遍历"></a>NSEnumerator遍历</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">NSArray *iosArray = @[@&quot;a&quot;, @&quot;b&quot;, @&quot;c&quot;, @&quot;d&quot;, @&quot;e&quot;, @&quot;f&quot;, @&quot;g&quot;];</div><div class="line">NSEnumerator *enumerator = [iosArray objectEnumerator];//正向遍历</div><div class="line">// NSEnumerator *enumerator = [iosArray reverseObjectEnumerator];//反向遍历</div><div class="line"></div><div class="line">id object;</div><div class="line"></div><div class="line">while ((object = [enumerator nextObject]) != nil) &#123;</div><div class="line">    //处理枚举器中的数据</div><div class="line">    NSLog(@&quot;%@&quot;, object);</div><div class="line">&#125;</div></pre></td></tr></table></figure></div><a href="/2017/04/20/iOS中遍历的总结/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/04/02/MQTT协议及推送服务/" class="post-title-link">MQTT协议及推送服务</a></h2><div class="post-info">Apr 2, 2017</div><div class="post-content"><h3 id="MQTT简介"><a href="#MQTT简介" class="headerlink" title="MQTT简介"></a>MQTT简介</h3><p>MQTT全称叫做Message Queuing Telemetry Transport，意为消息队列遥测传输，是IBM开发的一个即时通讯协议。由于其维护一个长连接以轻量级低消耗著称，所以常用于移动端消息推送服务开发。</p>
<h4 id="MQTT特性"><a href="#MQTT特性" class="headerlink" title="MQTT特性"></a>MQTT特性</h4><p>MQTT具有如下特性：</p>
<ul>
<li>使用发布／订阅消息模式，提供一对多消息发布；</li>
<li>对负载内容屏蔽的消息传输；</li>
<li><p>使用TCP/IP进行网络连接；</p>
<p>  主流的MQTT是基于TCP进行连接的，同样也有UDP版本的MQTT，但是不太常用，叫做MQTT-SN。</p>
</li>
<li><p>具有三种消息发布服务质量选项；</p>
<ol>
<li>“至多一次”，通常app的推送使用的就是这种模式。也就是说，如果移动设备在消息推送的时候没有联网，那么再次联网就不会收到通知了；</li>
<li>“至少一次”，可以确保消息收到，但消息可能会重复；</li>
<li>“只有一次”，确保消息到达一次，比如计费系统， 如果出现消息重复或者丢失会导致系统结果不正确的问题。</li>
</ol>
</li>
<li><p>小型传输，开销很小（固定长度的头部是2字节），协议交换最小化，以降低网络流量；</p>
<p>  这就是为什么MQTT能以轻量级低消耗著称，所以MQTT特别适用于低开销、低宽带占用的即时通讯场景。</p>
</li>
<li><p>通知有关各方客户端异常中断的机制。</p>
</li>
</ul></div><a href="/2017/04/02/MQTT协议及推送服务/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/02/20/有关Keychain服务，你需要了解这些/" class="post-title-link">有关Keychain服务，你需要了解这些</a></h2><div class="post-info">Feb 20, 2017</div><div class="post-content"><blockquote>
<p>在iOS系统中，Keychain提供了安全的存储服务，用来存储一些敏感信息。但是在日常开发中，我们经常会忽视这个苹果自荐的功能，本文的目的就是引起开发者的重视，敏感信息尽量使用Keychain服务。</p>
</blockquote>
<h3 id="NSUserDefaults不安全"><a href="#NSUserDefaults不安全" class="headerlink" title="NSUserDefaults不安全"></a>NSUserDefaults不安全</h3><p>NSUserDefaults其实是plist文件中键值存储，并且最大的问题是存在与沙盒中，这就对安全性埋下了隐患。如果攻击者破解app，拿到了沙盒中的数据，就会造成数据泄漏，后果不堪设想。</p>
<p>当然，一般也不会有把密码直接使用NSUserDefaults存储的，都会进行加密、或者是多重加密后再进行NSUserDefaults存储。这么做其实是可行的，前提是加密算法不能泄漏。有个小问题就是，如果用户删掉app重装的话，之前所有存储的敏感信息都会消失。比如，一个用户误删了使用NSUserDefaults存储密码的app，当重新安装之后，由于以前是记住密码免登录，只因为自己操作不当，接下来要进入找回密码功能，重新修改密码才能再次使用app。这对用户来说是一种相当不友好的体验。</p>
<p>所以，正确的姿势是使用Keychain服务来存储。Keychain保存的数据不仅仅是加密过的，而且由于Keychain是存在与沙盒之外的，当应用删除之后，app存储的数据并没有被删掉，第二次安装时只要读取Keychain里的数据，即可得到以前存储的信息。</p></div><a href="/2017/02/20/有关Keychain服务，你需要了解这些/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/12/10/浅谈iOS事件机制/" class="post-title-link">浅谈iOS事件机制</a></h2><div class="post-info">Dec 10, 2016</div><div class="post-content"><blockquote>
<p>在iOS的交互逻辑中，我们做的最多的是事件处理，今天我们就浅谈学习下iOS的事件传递机制。</p>
</blockquote>
<h3 id="iOS中的事件"><a href="#iOS中的事件" class="headerlink" title="iOS中的事件"></a>iOS中的事件</h3><p>在iOS中事件分为3类：</p>
<ul>
<li>Touch Events(触摸事件。包括单击、双击等)；</li>
<li>Motion Events(重力感应、晃动手机等等)；</li>
<li>Remote Events(远程事件，比如耳机音量按键的触发)。</li>
</ul>
<p>不过我们一般接触的Touch Events是最多的，其他两个就不多过介绍了，主要学习下Touch Events。</p>
<h3 id="事件的产生"><a href="#事件的产生" class="headerlink" title="事件的产生"></a>事件的产生</h3><p>在iOS中看到的UIButton可以点击，UIScrollView可以滑动，其实最根本的是UIResponder对象来实现的，只有继承了UIResponder，才能接收并处理事件响应。</p>
<p><code>UIResponder</code>并不是一个视图，是继承<code>NSObject</code>的一个对象。</p></div><a href="/2016/12/10/浅谈iOS事件机制/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/11/16/有关Block的一点总结/" class="post-title-link">有关Block的一点总结</a></h2><div class="post-info">Nov 16, 2016</div><div class="post-content"><blockquote>
<p>Block这种东西，基本上天天都会看到，最近闲下来，总结一下Block的基本知识。</p>
</blockquote>
<h3 id="Block基础用法"><a href="#Block基础用法" class="headerlink" title="Block基础用法"></a>Block基础用法</h3><p>从苹果官方文档来看，Block是一个OC对象，其实可以作为一个可以保存代码块的特殊对象来理解。在合适的时机去执行这块代码。</p>
<p>Block的种类有三种，无参数无返回值的Block、有参数无返回值的Block和有参数和有返回值的Block。</p>
<h4 id="无参数无返回值的Block"><a href="#无参数无返回值的Block" class="headerlink" title="无参数无返回值的Block"></a>无参数无返回值的Block</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">void (^(testBlock))() = ^() &#123;</div><div class="line">    NSLog(@&quot;textBlock&quot;);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">testBlock();</div></pre></td></tr></table></figure>
<h4 id="有参数无返回值的Block"><a href="#有参数无返回值的Block" class="headerlink" title="有参数无返回值的Block"></a>有参数无返回值的Block</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">void (^(appendString))(NSString *str1, NSString *str2) = ^(NSString *str1, NSString *str2) &#123;</div><div class="line">    NSString *appendStr = [NSString stringWithFormat:@&quot;%@%@&quot;, str1, str2];</div><div class="line">    NSLog(@&quot;%@&quot;, appendStr);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">appendString(@&quot;123&quot;, @&quot;456&quot;);</div></pre></td></tr></table></figure>
<h4 id="有参数有返回值的Block"><a href="#有参数有返回值的Block" class="headerlink" title="有参数有返回值的Block"></a>有参数有返回值的Block</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">NSString* (^(appendString))(NSString *str1, NSString *str2) = ^(NSString *str1, NSString *str2) &#123;</div><div class="line">    NSString *appendStr = [NSString stringWithFormat:@&quot;%@%@&quot;, str1, str2];</div><div class="line">    return appendStr;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">NSLog(@&quot;%@&quot;, appendString(@&quot;123&quot;, @&quot;456&quot;));</div></pre></td></tr></table></figure>
<p>这些事Block的基本用法，不过并不是这篇文章的关键，在总结Block的关键知识点之前，我们先来回顾一下iOS的内存分配机制。</p></div><a href="/2016/11/16/有关Block的一点总结/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/04/21/Swift学习之闭包/" class="post-title-link">Swift学习之闭包</a></h2><div class="post-info">Apr 21, 2016</div><div class="post-content"><blockquote>
<p>作为一门现代编程语言，Swift对函数式编程范式有着良好的支持，而函数式编程又和闭包有着紧密的关系，今天我们就学习下闭包这个概念。</p>
</blockquote>
<p>闭包的出现，可能会打破脑海中存在已久的函数概念，</p>
<p>一般来说，一个函数只会有一个实例，而闭包的出现，使得函数可以有多个实例。当然，函数得处于其相关的上下文环境中。闭包这个概念，在OC/C中叫做Blocks，用过的人都知道，好难理解Blocks这东西到底是干嘛的，十分晦涩。原因在于，不管是OC或者是Java，都是一门面向对象语言，由于面向对象语言本身对函数具有局限性，闭包的实现，是迫于编程语言的发展趋势而添加的特性，光看代码，就感觉好像一个补丁。  </p>
<p>在说闭包之前，需要先谈谈“自由变量”这个概念，那么什么是自由变量呢？</p>
<blockquote>
<p>本意应该是在一个作用域中，如果使用未在本作用域中声明的变量，那么对于此作用域，该变量就是一个自由变量。</p>
</blockquote>
<p>而闭包，就是一个引用了自由变量的函数，自由变量将和函数一同存在。  </p>
<p>在谈谈“高阶函数”，什么是高阶函数？</p>
<blockquote>
<p>高阶函数就是接受一个或者多个函数当作参数，并且返回值也是个函数的函数。</p>
</blockquote>
<p>在命令式的编程语言中，对函数的看法往往比较局限，认为函数就是一系列语句的集合。而在函数式编程语言中，函数是十分灵活的，这就使得在Swift中闭包变得十分简单，在Swift中，函数都是高阶函数，而高阶函数需要函数先成为闭包，下面给个简单的高阶函数的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">func makeCounter() -&gt; (() -&gt; Int) &#123;</div><div class="line">    var count = 0</div><div class="line"></div><div class="line">    func add() -&gt; Int &#123;</div><div class="line">        count += 1</div><div class="line">        return count</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return add</div><div class="line">&#125;</div><div class="line"></div><div class="line">let add = makeCounter()</div><div class="line">add()		//1</div><div class="line">add()		//2</div></pre></td></tr></table></figure>
<p>例子是实现一个自增的高阶函数，我们可以看出，<code>makeCounter</code>返回的并不是一个数据值，而是一个函数。当我们在全局中获取到<code>makeCounter</code>的返回函数后，每执行一次，都会进行加一操作，说明虽然我们离开了<code>count</code>的作用域，但还是可以使用<code>count</code>的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let add2 = makeCounter()</div><div class="line">add2()		//1</div><div class="line">add2()		//2</div></pre></td></tr></table></figure>
<p>我们再来获取一个函数返回值，会发现，输出结果依然是1、2。这说明，此函数可以有多个实例，它们有着自己的count值，之间并不共享。  </p></div><a href="/2016/04/21/Swift学习之闭包/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/04/05/Swift之自动引用计数/" class="post-title-link">Swift之自动引用计数</a></h2><div class="post-info">Apr 5, 2016</div><div class="post-content"><blockquote>
<p>这个概念并不是Swift专有，在Objective-C中就已经运用广泛。运用这种机制，能很好地跟踪和管理应用程序的内存。  </p>
</blockquote>
<p>在早期，Apple一直使用的是MRC，这篇文章并不想讲解MRC，使用MRC时，Swift还没有诞生呢。MRC是手动管理内存的，比如创建一个实例对象，如果需要释放该对象，是需要手动去释放的。而使用ARC的好处是，ARC可以自动的帮您管理内存，自动释放其占有的内存。  </p>
<p>特别注意：不管是ARC还是MRC，引用计数只仅仅应用于类的实例，不能应用于结构体和枚举类型。  </p>
<h3 id="自动引用计数原理"><a href="#自动引用计数原理" class="headerlink" title="自动引用计数原理"></a>自动引用计数原理</h3><p>首先记住，每创建一个新的实例，ARC会自动分配给一块内存用来存储实例的信息，当内存不再使用时，ARC会释放实例所占的内存，供其他实例使用。  </p>
<p>为了分辨实例是否正在处于使用的情况，ARC会跟踪和计算每一个实例的引用次数，如果实例的引用次数小于1，那么ARC会销毁这个实例。  </p>
<p>下面给出一个例子，用来解释ARC的运行机制，我们先实现一个Person类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class Person &#123;</div><div class="line">    let name: String</div><div class="line"></div><div class="line">    init(name: String) &#123;</div><div class="line">        self.name = name</div><div class="line">        print(&quot;\(name)正在被初始化&quot;)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    deinit &#123;</div><div class="line">        print(&quot;\(name)正在被销毁&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Person类很简单，有一个名为name的属性，然后重写<code>init</code>和<code>deinit</code>方法。然后我们定义三个变量来对Person类进行引用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var person1: Person?</div><div class="line">var person2: Person?</div><div class="line">var person3: Person?</div></pre></td></tr></table></figure>
<p>可选选项可以保证在没实例化之前是nil。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">person1 = Person(name: &quot;Jack&quot;)</div><div class="line">person2 = person1</div><div class="line">person3 = person1</div></pre></td></tr></table></figure>
<p>当我们对person1执行实例化时，会打印出<code>Jack正在被初始化</code>，说明Person实例赋值给了person1，需要注意的是，两者之间是建立了一个强引用，强引用可以保证Person实例可以保持在内存中不被销毁。将同一个实例也赋值给person2和person3，又回多出两个强引用，所以现在Person实例有三个强引用。  </p>
<p>接下来我们通过赋值<code>nil</code>来断开强引用关系。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">person1 = nil</div><div class="line">person2 = nil</div></pre></td></tr></table></figure>
<p>然后我们断开person3的强引用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">person3 = nil</div></pre></td></tr></table></figure>
<p>这时我们发现，Console中打印出了<code>Jack正在被销毁</code>的log。所以说明，当一个实例不再有强引用关系时，ARC会自动销毁存在在内存中的该实例，释放内存供其他实例使用。</p></div><a href="/2016/04/05/Swift之自动引用计数/" class="read-more">...more</a></article></li></ul></main><footer><div class="paginator"><a href="/page/2/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2017 <a href="http://yoursite.com">Hyyy</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>