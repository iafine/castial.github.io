<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hyyy的技术博客</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-06-18T07:52:26.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Hyyy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS小结之多线程</title>
    <link href="http://yoursite.com/2017/06/18/iOS%E5%B0%8F%E7%BB%93%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yoursite.com/2017/06/18/iOS小结之多线程/</id>
    <published>2017-06-18T07:49:32.000Z</published>
    <updated>2017-06-18T07:52:26.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>小结第三篇，来总结总结iOS中多线程操作。</p>
</blockquote>
<h3 id="多线程概述"><a href="#多线程概述" class="headerlink" title="多线程概述"></a>多线程概述</h3><p>对于ios系统中的某个App来讲，是单进程多线程方式来工作。一般来说，使用多线程的好处是可以把程序分成相对独立的几个模块，可以有效的防止某个模块堵塞的时候导致整个程序卡死；还有就是提高运行效率，现在CPU都是多核，多个核可以同时跑，可以同时执行多条线程。</p>
<p>谈细节之前里，我们得说下有关多线程的几个概念。</p>
<h4 id="串行和并发"><a href="#串行和并发" class="headerlink" title="串行和并发"></a>串行和并发</h4><p>串行的意思是在多个任务下，每次只会有一个任务被执行，并发的意思是同一时间多个任务同时发生。并发是一种现象，解决并发现象的技术，叫做并行。我们经常说的多线程编程，说的就是并行技术，可以让多个CPU同时执行，加快执行速度，提高执行效率。</p>
<h4 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h4><p>同步的意思是在多任务中，一个任务只能等待另一个任务完成之后，他才可以进行，而异步的意思是一个任务的执行，不需要等待上一个任务的执行，不会发生堵塞。</p>
<h4 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h4><p>临界区是一种资源，这块资源不能并发执行，就叫做临界区。我们一般所看到的，临界区就是一个代码块。因为临界区资源如果可以被多个线程同时进行操作，比如读写，就可能出现异常。</p>
<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>死锁就是指两条线程互相都在等待对方执行完毕，才能进入下一步操作。由于两条线程都不能执行下一步，所以造成死锁，卡住不动了。</p>
<h4 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h4><p>线程安全在iOS开发中应该听到多很多次，指的是在多线程中或者并发任务中可以被安全地调用，就称为线程安全。比如<code>NSDictionary</code>就是线程安全的，可以在多线程中使用它，不会出现问题，而<code>NSMutableDictionary</code>是线程不安全的，所以使用<code>NSMutableDictionary</code>的时候应该保证每次只能有一个线程访问它。</p>
<h4 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h4><p>上下文切换指的是在一条进程中切换不同线程时，线程的等待和恢复执行的过程。这一过程中会带来一些额外的开销。</p>
<a id="more"></a>
<h3 id="iOS多线程方案"><a href="#iOS多线程方案" class="headerlink" title="iOS多线程方案"></a>iOS多线程方案</h3><h4 id="Pthreads"><a href="#Pthreads" class="headerlink" title="Pthreads"></a>Pthreads</h4><p><code>Pthreads</code>是基于C语言的通用多线程API，在日常开发中基本上用不到，并且目前在Swift中貌似并不能直接调用这套API。所以这种方案只提一下，不过多介绍。</p>
<h4 id="NSThread"><a href="#NSThread" class="headerlink" title="NSThread"></a>NSThread</h4><p><code>NSThread</code>是一套比较轻量级的多线程方案，可以直观地控制线程对象，一个<code>NSThread</code>代表一条线程，但是需要自己管理线程的生命周期，线程同步等问题，</p>
<p>创建thread目前所了解到的有4种方式，其中类方法两个，实例方法两个。类方法创建线程后会自动启动该线程，而实例方法只会创建线程，启动需要手动去做。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// 第一种类方法</div><div class="line">[NSThread detachNewThreadSelector:@selector(threadHandler) toTarget:self withObject:nil];</div><div class="line"></div><div class="line">- (void)threadHandler &#123;</div><div class="line">    NSThread *currentThread = [NSThread currentThread];</div><div class="line">    NSLog(@&quot;current thread: %@&quot;, currentThread);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 第二个类方法</div><div class="line">[NSThread detachNewThreadWithBlock:^&#123;</div><div class="line">    NSLog(@&quot;block current thread: %@&quot;, [NSThread currentThread]);</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>下面是两种实例方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">// 第一个实例方法</div><div class="line">NSThread *thread1 = [[NSThread alloc] initWithBlock:^&#123;</div><div class="line">    NSLog(@&quot;current thread: %@&quot;, [NSThread currentThread]);</div><div class="line">&#125;];</div><div class="line">[thread1 start];</div><div class="line"></div><div class="line">// 第二个实例方法</div><div class="line">NSThread *thread2 = [[NSThread alloc] initWithTarget:self selector:@selector(threadHandler:) object:@&#123;@&quot;title&quot; : @&quot;2123&quot;&#125;];</div><div class="line">[thread2 start];</div><div class="line"></div><div class="line">- (void)threadHandler:(NSDictionary *)dic &#123;</div><div class="line">    NSThread *currentThread = [NSThread currentThread];</div><div class="line">    NSLog(@&quot;current thread: %@&quot;, currentThread);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>除了上面的之外，<code>NSThread</code>还提供了一个<code>NSObject+NSThreadPerformAdditions</code>，用于在NSObject中执行线程调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// 在主线程执行一个任务，后者区别在于可以指定在哪种Runloop模式下运行，有关Runloop可以参考上篇文章。</div><div class="line">[self performSelectorOnMainThread:@selector(threadHandler:) withObject:@&#123;@&quot;title&quot; : @&quot;123&quot;&#125; waitUntilDone:YES];</div><div class="line">[self performSelectorOnMainThread:@selector(threadHandler:) withObject:@&#123;@&quot;title&quot; : @&quot;123&quot;&#125; waitUntilDone:YES modes:@[NSDefaultRunLoopMode]];</div><div class="line"></div><div class="line">// 在指定的线程中执行一个任务。</div><div class="line">[self performSelector:@selector(threadHandler:) onThread:[NSThread currentThread] withObject:@&#123;@&quot;title&quot; : @&quot;123&quot;&#125; waitUntilDone:YES];</div><div class="line">[self performSelector:@selector(threadHandler:) onThread:[NSThread currentThread] withObject:@&#123;@&quot;title&quot; : @&quot;123&quot;&#125; waitUntilDone:YES modes:@[NSDefaultRunLoopMode]];</div><div class="line"></div><div class="line">// 在后台隐形创建线程，执行一个任务</div><div class="line">[self performSelectorInBackground:@selector(threadHandler:) withObject:@&#123;@&quot;title&quot; : @&quot;123&quot;&#125;];</div><div class="line"></div><div class="line">- (void)threadHandler:(NSDictionary *)dic &#123;</div><div class="line">    NSThread *currentThread = [NSThread currentThread];</div><div class="line">    NSLog(@&quot;current thread: %@&quot;, currentThread);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>另外，NSThread还提供了设置线程优先级功能，叫做NSQualityOfService，一共分为一下几种：</p>
<ul>
<li>NSQualityOfServiceUserInteractive。用于用户交互，最高优先级</li>
<li>NSQualityOfServiceUserInitiated。用于执行需要立即返回的的任务，次高优先级</li>
<li>NSQualityOfServiceDefault。线程默认优先级</li>
<li>NSQualityOfServiceUtility。用于执行普通任务，普通优先级</li>
<li>NSQualityOfServiceBackground。最低优先级，用于执行不重要的任务</li>
</ul>
<p>还有其他一些线程操作，具体如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">// 线程休眠，休眠线程会阻塞当前线程</div><div class="line">[NSThread sleepForTimeInterval:5.0];</div><div class="line">[NSThread sleepUntilDate:[NSDate dateWithTimeIntervalSinceNow:5.0]];</div><div class="line"></div><div class="line">// 线程取消，调用此方法并不会马上停止线程运行，只仅仅是线程状态记录</div><div class="line">[thread cancel];</div><div class="line"></div><div class="line">// 线程停止，执行此方法会立即终止主线程外其他所有线程，所以调用请慎用。</div><div class="line">[NSThread exit];</div><div class="line"></div><div class="line">// 获取当前线程</div><div class="line">[NSThread currentThread];</div><div class="line"></div><div class="line">// 获取主线程</div><div class="line">[NSThread mainThread];</div><div class="line"></div><div class="line">// 停止当前线程的Runloop</div><div class="line">CFRunLoopStop(CFRunLoopGetCurrent());</div></pre></td></tr></table></figure>
<p>如果有多个线程共享一块资源，对资源进行操作时候，还涉及到线程同步问题，一段时间只允许一条线程来操作资源，不然会引起冲突，iOS实现线程加锁有NSLock和@synchronized两种方式。其用法也比较简单，在这里就不过多介绍。</p>
<h4 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h4><p>GCD全称是Grand Central Dispatch，是为了给iOS和mac的多核硬件上执行支持，其实现方式是一套底层C API。通过GCD，开发者不用和线程打交道，只需要使用一个Block就可以实现多线程操作。GCD提供的API简单易懂，提供了一个易于使用的并发模型，对于开发者来说，并不需要关心多线程的并发问题，GCD底层自动处理这些逻辑。</p>
<p>出了这些之外，GCD其实还可以根据当前的系统负载来增减线程数量，我们都知道线程的创建切换都是需要代价的，是有消耗的，所以使用GCD还可以增加效率，提供更高的性能。</p>
<p>GCD操作是需要通过队列来操作的，有三种队列可以使用。</p>
<ul>
<li>串行队列(Serial)。串行队列的特点是以先进先出的顺序来执行的，队列内的东西是以顺序执行的，但是多个串行队列直接是以并发执行的。</li>
<li>并行队列(Concurrent)。并行队列和串行队列相反，可以同时执行多个任务，但是多个任务之间，仍然是以先进先出的顺序执行的，区别在于，并行队列会跟酒系统负载，尽可能多地创建线程去执行这些任务。但是哪个任务先执行完毕是不确定的。</li>
<li>主线程队列(Main dispatch queue)。实际上，主线程队列是一个和主线程相关的串行队列。这个队列中的任务每次只会有一个执行。可以保证所有的任务都会在主线程执行，所以涉及到UI操作的需要使用这个队列来完成。</li>
</ul>
<p>创建一个串行队列，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t queue = dispatch_queue_create(@&quot;com.hyyy.gcd&quot;, DISPATCH_QUEUE_SERIAL);</div><div class="line"></div><div class="line">// 这种也可以，NULL默认就是串行</div><div class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;com.hyyy.gcd&quot;, NULL);</div></pre></td></tr></table></figure>
<p>创建一个并行队列，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;coml.hyyy.gcd&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class="line"></div><div class="line">// 也可以用下面这种</div><div class="line">dispatch_queue_t queue = dispatch_get_global_queue(0, 0);</div></pre></td></tr></table></figure>
<p>主线程队列：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t queue = dispatch_get_main_queue();</div></pre></td></tr></table></figure>
<p>GCD往队列里添加任务有两种方式，一种是异步，一种是同步。</p>
<ul>
<li>异步(dispatch_async)。是一个异步添加操作，dispatch_async会立即返回；</li>
<li>同步(dispatch_sync)。是一个同步添加操作，dispatch_sync区别是会阻塞当前线程，会等待block里的任务执行完毕之后才会返回。</li>
</ul>
<p>dispatch_async添加任务，会立即返回，所以下面的打印顺序不确定。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">    NSLog(@&quot;========1&quot;);</div><div class="line"></div><div class="line">&#125;);</div><div class="line">NSLog(@&quot;========2&quot;);</div><div class="line"></div><div class="line">// 执行结果：</div><div class="line">ThreadTest[17614:2597588] ========2</div><div class="line">ThreadTest[17614:2597588] ========1</div></pre></td></tr></table></figure>
<p>如果是dispatch_sync，由于是同步，所以打印结果是有顺序的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;com.hyyy.gcd&quot;, NULL);</div><div class="line">dispatch_sync(queue, ^&#123;</div><div class="line">    NSLog(@&quot;========1&quot;);</div><div class="line"></div><div class="line">&#125;);</div><div class="line">NSLog(@&quot;========2&quot;);</div><div class="line"></div><div class="line">// 执行结果</div><div class="line">ThreadTest[17599:2595130] ========1</div><div class="line">ThreadTest[17599:2595130] ========2</div></pre></td></tr></table></figure>
<p>但是dispatch_sync尽量少用，使用不当会造成死锁。比如下面的代码就会造成死锁：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">dispatch_sync(dispatch_get_main_queue(), ^(void)&#123;</div><div class="line">    NSLog(@&quot;这里死锁了&quot;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>需要注意的是，死锁并不是这里使用了主线程造成的，不用主线程，照样可以造成死锁。如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t serialQueue = dispatch_queue_create(&quot;com.hyyy.thread&quot;, DISPATCH_QUEUE_SERIAL);</div><div class="line">NSLog(@&quot;========1&quot;);</div><div class="line">dispatch_async(serialQueue, ^&#123;</div><div class="line">    NSLog(@&quot;========2&quot;);</div><div class="line">    dispatch_sync(serialQueue, ^&#123;</div><div class="line">        NSLog(@&quot;========3&quot;);</div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这种也会发生死锁，所以不要听信什么主线程的问题，不是主线程照样可以发生死锁。死锁真的发生的原因是dispatch_sync添加进的queue队列是当前queue队列。在主线程死锁的那段代码中，我们调用的dispatch_sync是添加在主线程queue中，使主线程堵塞，而我们的Block又需要主线程queue来执行，所以相互等待，造成死锁了。</p>
<p>但是为什么添加队列换成并行队列就不会有问题呢？还是上面的概念，对于并行队列中任务的执行，其执行开始和结束并不取决于上一个任务的结束时间，只仅仅取决于任务的耗时。即便任务是以同步的方式添加进去，但是在并行队列中也会在另外一个线程去跑这个任务。</p>
<p>这里还需要提一个题外话，在并发队列里的Block何时执行，开发者是不用知道的，完全取决于GCD，但是我们也是有方法可以让其按照顺序执行。</p>
<p>GCD的使用场景有很多，我们一个一个举例来说明。</p>
<p><strong>后台下载显示图片</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class="line">    NSURL * url = [NSURL URLWithString:@&quot;http://www.yourimage.com&quot;];</div><div class="line">    NSError * error;</div><div class="line">    NSString * data = [NSString stringWithContentsOfURL:url encoding:NSUTF8StringEncoding error:&amp;error];</div><div class="line">    if (data != nil) &#123;</div><div class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">            self.imageView.image = [UIImage imageWithData:data];</div><div class="line">        &#125;);</div><div class="line">    &#125; else &#123;</div><div class="line">        NSLog(@&quot;error when download:%@&quot;, error);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这是一个经典的使用场景，有时候我们需要后台处理一个任务，然后在主线程进行UI渲染，可以这么干。</p>
<p><strong>单例模式</strong></p>
<p>单例模式是设计模式中最简单的一种了，它的目的是创建的类对象在系统中是唯一的，一个类只有一个实例，节约系统资源。一般我们创建一个单例会这么做：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">//Singleton.h</div><div class="line">@interface Singleton : NSObject</div><div class="line">+ (Singleton *)sharedInstance;</div><div class="line">@end</div><div class="line"></div><div class="line">//Singleton.m</div><div class="line">@implementation Singleton</div><div class="line">static Singleton * sharedSingleton = nil;</div><div class="line">+ (Singleton *) sharedInstance &#123;</div><div class="line">    static dispatch_once_t onceToken;</div><div class="line">    dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">        sharedSingleton = [[Singleton alloc] init];</div><div class="line">    &#125;);</div><div class="line">    return sharedSingleton;</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>这里我们用到了dispatch_once_t，对于给定的token来说，Block里的代码必定会执行，并且会仅执行一次。最重要的一点是，这里的操作是线程安全的，十分高效。但是需要注意的是token这个东西是应该声明称static或者global，这样来保证每次传进去的token是相同的。</p>
<p><strong>dispatch_after延后执行</strong></p>
<p>dispatch_after可以做到使一块代码延时执行，但是需要注意的是，这里的延时是有歧义的，dispatch_after做到的仅是延时把这一项任务提交到队列中去，至于什么时候执行，是和GCD内部处理逻辑有关的。</p>
<p>比如我想0.5秒之后发送一条通知，可以这么干。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</div><div class="line">    [[NSNotificationCenter defaultCenter] postNotificationName:HY_AFTER_NOTIFICATION object:nil];</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><strong>dispatch_apply快速迭代</strong></p>
<p>dispatch_apply和遍历的效果差不多，其作用是把指定次数的block添加到queue中，好处是dispatch_apply可以不用管理线程方面的问题，GCD会自动处理并发现象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">NSArray *array = @[@&quot;a&quot;, @&quot;b&quot;, @&quot;c&quot;, @&quot;d&quot;, @&quot;e&quot;, @&quot;f&quot;, @&quot;g&quot;];</div><div class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;queue&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class="line">dispatch_apply(array.count, queue, ^(size_t i) &#123;</div><div class="line">    NSString *str = [array objectAtIndex:i];</div><div class="line">    NSLog(@&quot;number: %@&quot;, str);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><strong>Dispatch_groups</strong></p>
<p>Dispatch_groups作用是用来监视多个并行任务的执行，来进行线程同步的。在多个任务执行完毕后，想要执行结束处理，就可以使用Dispatch_groups来完成。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t queue1 = dispatch_queue_create(&quot;com.hyyy.gcd&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class="line">dispatch_queue_t queue2 = dispatch_get_global_queue(0, 0);</div><div class="line">dispatch_group_t group = dispatch_group_create();</div><div class="line">dispatch_group_async(group, queue1, ^&#123;</div><div class="line">    NSLog(@&quot;========1&quot;);</div><div class="line">&#125;);</div><div class="line">dispatch_group_async(group, queue1, ^&#123;</div><div class="line">    NSLog(@&quot;========2&quot;);</div><div class="line">&#125;);</div><div class="line">dispatch_group_async(group, queue2, ^&#123;</div><div class="line">    NSLog(@&quot;========3&quot;);</div><div class="line">&#125;);</div><div class="line">dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</div><div class="line">    NSLog(@&quot;========end&quot;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">// 运行结果</div><div class="line">========3</div><div class="line">========1</div><div class="line">========2</div><div class="line">========end</div></pre></td></tr></table></figure>
<p>可以看到，上面三个任务执行完毕之后，才会走最后一个block回调，我们可以利用这种模式做很多事。但是千万不要像下面这么写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t queue1 = dispatch_queue_create(&quot;com.hyyy.gcd&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class="line">dispatch_queue_t queue2 = dispatch_get_global_queue(0, 0);</div><div class="line">dispatch_group_t group = dispatch_group_create();</div><div class="line">dispatch_group_async(group, queue1, ^&#123;</div><div class="line">    dispatch_async(queue2, ^&#123;</div><div class="line">        NSLog(@&quot;========1&quot;);</div><div class="line">    &#125;);</div><div class="line">&#125;);</div><div class="line">dispatch_group_async(group, queue1, ^&#123;</div><div class="line">    dispatch_async(queue2, ^&#123;</div><div class="line">        NSLog(@&quot;========2&quot;);</div><div class="line">    &#125;);</div><div class="line">&#125;);</div><div class="line">dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</div><div class="line">    NSLog(@&quot;========end&quot;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这么写会有问题，dispatch_group_async里执行的是异步任务，而dispatch_group_notify并不会等待异步任务完成，如果真的这么做，那就需要dispatch_group_enter和dispatch_group_leave来进行约束，也是我用的比较多的一种。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t queue = dispatch_get_global_queue(0, 0);</div><div class="line">dispatch_group_t group = dispatch_group_create();</div><div class="line">dispatch_group_enter(group);</div><div class="line">dispatch_async(queue, ^&#123;</div><div class="line">    sleep(3);</div><div class="line">    NSLog(@&quot;========1&quot;);</div><div class="line">    dispatch_group_leave(group);</div><div class="line">&#125;);</div><div class="line">dispatch_group_enter(group);</div><div class="line">dispatch_async(queue, ^&#123;</div><div class="line">    sleep(3);</div><div class="line">    NSLog(@&quot;========2&quot;);</div><div class="line">    dispatch_group_leave(group);</div><div class="line">&#125;);</div><div class="line">dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</div><div class="line">    sleep(3);</div><div class="line">    NSLog(@&quot;========end&quot;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>需要注意的事，dispatch_group_enter和dispatch_group_leave总是对应出现的，类似于引用计数原理，有加有减。</p>
<p><strong>dispatch_barrier并发问题</strong></p>
<p>在并行队列里，有时候我们需要每次只单独执行一个任务，也就是当有个任务执行的时候，不允许其他任务执行，类似于多线程读写问题，这时候Dispatch Barrier就发挥了作用。</p>
<p>Dispatch Barrier可以保证提交的block是指定队列里某个时段唯一执行的一个，下面用一个示例来演示一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t dataQueue = dispatch_queue_create(&quot;com.hyyy.gcd&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class="line">dispatch_async(dataQueue, ^&#123;</div><div class="line">    [NSThread sleepForTimeInterval:2.f];</div><div class="line">    NSLog(@&quot;读数据&quot;);</div><div class="line">&#125;);</div><div class="line">dispatch_async(dataQueue, ^&#123;</div><div class="line">    NSLog(@&quot;读数据&quot;);</div><div class="line">&#125;);</div><div class="line">//等待前面的都完成，在执行barrier后面的</div><div class="line">dispatch_barrier_async(dataQueue, ^&#123;</div><div class="line">    NSLog(@&quot;写数据&quot;);</div><div class="line">    [NSThread sleepForTimeInterval:1];</div><div class="line">&#125;);</div><div class="line">dispatch_async(dataQueue, ^&#123;</div><div class="line">    [NSThread sleepForTimeInterval:1.f];</div><div class="line">    NSLog(@&quot;读数据&quot;);</div><div class="line">&#125;);</div><div class="line">dispatch_async(dataQueue, ^&#123;</div><div class="line">    NSLog(@&quot;读数据&quot;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>在进行写数据的时候，因为使用了Dispatch Barrier，不会发生读数据的操作，所以保证了每次写入数据只会有一个任务在执行。</p>
<h4 id="NSOperation"><a href="#NSOperation" class="headerlink" title="NSOperation"></a>NSOperation</h4><p>相比于GCD，NSOperation显得并没有那么流行，但是称得上是先进的面向对象的多线程解决办法。同样，对于开发者来讲，我们根本不用考虑线程的生命周期、同步，加锁等晦涩问题。</p>
<p>使用NSOperation有三种方式，NSInvocationOperation、NSBlockOperation和自定义子类继承NSOperation。</p>
<p><strong>NSInvocationOperation</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">NSInvocationOperation *operation = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(operationHandler) object:nil];</div><div class="line">[operation start];</div><div class="line"></div><div class="line">- (void)operationHandler &#123;</div><div class="line">    NSLog(@&quot;current thread: %@&quot;, [NSThread currentThread]);</div><div class="line">    NSLog(@&quot;main thread: %@&quot;, [NSThread mainThread]);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 运行结果</div><div class="line">current thread: &lt;NSThread: 0x60000007a840&gt;&#123;number = 1, name = main&#125;</div><div class="line">main thread: &lt;NSThread: 0x60000007a840&gt;&#123;number = 1, name = main&#125;</div></pre></td></tr></table></figure>
<p>NSInvocationOperation默认情况下，并不会新开一个线程去跑，而是在当前线程去执行任务，可以将NSInvocationOperation放到NSOperationQueue中，即可实现异步操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">NSInvocationOperation *operation = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(operationHandler) object:nil];</div><div class="line"></div><div class="line">NSOperationQueue *queue = [[NSOperationQueue alloc] init];</div><div class="line">[queue addOperation:operation];</div><div class="line"></div><div class="line">- (void)operationHandler &#123;</div><div class="line">    NSLog(@&quot;current thread: %@&quot;, [NSThread currentThread]);</div><div class="line">    NSLog(@&quot;main thread: %@&quot;, [NSThread mainThread]);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 运行结果</div><div class="line">current thread: &lt;NSThread: 0x600000077140&gt;&#123;number = 3, name = (null)&#125;</div><div class="line">main thread: &lt;NSThread: 0x60800006e440&gt;&#123;number = 1, name = (null)&#125;</div></pre></td></tr></table></figure>
<p><strong>NSBlockOperation</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">NSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^&#123;</div><div class="line">    NSLog(@&quot;current thread: %@&quot;, [NSThread currentThread]);</div><div class="line">    NSLog(@&quot;main thread: %@&quot;, [NSThread mainThread]);</div><div class="line">&#125;];</div><div class="line">[operation start];</div><div class="line"></div><div class="line">// 运行结果</div><div class="line">current thread: &lt;NSThread: 0x6000000753c0&gt;&#123;number = 1, name = main&#125;</div><div class="line">main thread: &lt;NSThread: 0x6000000753c0&gt;&#123;number = 1, name = main&#125;</div></pre></td></tr></table></figure>
<p>和NSInvocationOperation一样，默认NSBlockOperation只会在当前线程上执行。如果需要新开线程操作，可以添加到NSOperationQueue中即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">NSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^&#123;</div><div class="line">    NSLog(@&quot;current thread: %@&quot;, [NSThread currentThread]);</div><div class="line">    NSLog(@&quot;main thread: %@&quot;, [NSThread mainThread]);</div><div class="line">&#125;];</div><div class="line">NSOperationQueue *queue = [[NSOperationQueue alloc] init];</div><div class="line">[queue addOperation:operation];</div><div class="line"></div><div class="line">// 运行结果</div><div class="line">current thread: &lt;NSThread: 0x60800007d7c0&gt;&#123;number = 3, name = (null)&#125;</div><div class="line">main thread: &lt;NSThread: 0x6000000767c0&gt;&#123;number = 1, name = (null)&#125;</div></pre></td></tr></table></figure>
<p>另外，可以使用addExecutionBlock添加额外的操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">NSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^&#123;</div><div class="line">    NSLog(@&quot;current thread: %@&quot;, [NSThread currentThread]);</div><div class="line">&#125;];</div><div class="line">[operation addExecutionBlock:^&#123;</div><div class="line">    NSLog(@&quot;current thread: %@&quot;, [NSThread currentThread]);</div><div class="line">&#125;];</div><div class="line">[operation addExecutionBlock:^&#123;</div><div class="line">    NSLog(@&quot;current thread: %@&quot;, [NSThread currentThread]);</div><div class="line">&#125;];</div><div class="line">[operation addExecutionBlock:^&#123;</div><div class="line">    NSLog(@&quot;current thread: %@&quot;, [NSThread currentThread]);</div><div class="line">&#125;];</div><div class="line">[operation start];</div><div class="line"></div><div class="line">// 运行结果</div><div class="line">current thread: &lt;NSThread: 0x6000000771c0&gt;&#123;number = 1, name = main&#125;</div><div class="line">current thread: &lt;NSThread: 0x600000264280&gt;&#123;number = 5, name = (null)&#125;</div><div class="line">current thread: &lt;NSThread: 0x608000260980&gt;&#123;number = 4, name = (null)&#125;</div><div class="line">current thread: &lt;NSThread: 0x6000002640c0&gt;&#123;number = 3, name = (null)&#125;</div></pre></td></tr></table></figure>
<p>可以看到，使用addExecutionBlock会在新线程中去执行。但是并不是每次都会创建，我们可以试下多创建几个：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">NSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^&#123;</div><div class="line">    NSLog(@&quot;current thread: %@&quot;, [NSThread currentThread]);</div><div class="line">&#125;];</div><div class="line">[operation addExecutionBlock:^&#123;</div><div class="line">    NSLog(@&quot;current thread: %@&quot;, [NSThread currentThread]);</div><div class="line">&#125;];</div><div class="line">[operation addExecutionBlock:^&#123;</div><div class="line">    NSLog(@&quot;current thread: %@&quot;, [NSThread currentThread]);</div><div class="line">&#125;];</div><div class="line">[operation addExecutionBlock:^&#123;</div><div class="line">    NSLog(@&quot;current thread: %@&quot;, [NSThread currentThread]);</div><div class="line">&#125;];</div><div class="line">[operation addExecutionBlock:^&#123;</div><div class="line">    NSLog(@&quot;current thread: %@&quot;, [NSThread currentThread]);</div><div class="line">&#125;];</div><div class="line">[operation addExecutionBlock:^&#123;</div><div class="line">    NSLog(@&quot;current thread: %@&quot;, [NSThread currentThread]);</div><div class="line">&#125;];</div><div class="line">[operation addExecutionBlock:^&#123;</div><div class="line">    NSLog(@&quot;current thread: %@&quot;, [NSThread currentThread]);</div><div class="line">&#125;];</div><div class="line">[operation addExecutionBlock:^&#123;</div><div class="line">    NSLog(@&quot;current thread: %@&quot;, [NSThread currentThread]);</div><div class="line">&#125;];</div><div class="line">[operation addExecutionBlock:^&#123;</div><div class="line">    NSLog(@&quot;current thread: %@&quot;, [NSThread currentThread]);</div><div class="line">&#125;];</div><div class="line">[operation addExecutionBlock:^&#123;</div><div class="line">    NSLog(@&quot;current thread: %@&quot;, [NSThread currentThread]);</div><div class="line">&#125;];</div><div class="line">[operation start];</div><div class="line"></div><div class="line">// 运行结果</div><div class="line">current thread: &lt;NSThread: 0x600000065600&gt;&#123;number = 1, name = main&#125;</div><div class="line">current thread: &lt;NSThread: 0x600000065600&gt;&#123;number = 1, name = main&#125;</div><div class="line">current thread: &lt;NSThread: 0x600000065600&gt;&#123;number = 1, name = main&#125;</div><div class="line">current thread: &lt;NSThread: 0x600000065600&gt;&#123;number = 1, name = main&#125;</div><div class="line">current thread: &lt;NSThread: 0x608000071bc0&gt;&#123;number = 4, name = (null)&#125;</div><div class="line">current thread: &lt;NSThread: 0x600000065600&gt;&#123;number = 1, name = main&#125;</div><div class="line">current thread: &lt;NSThread: 0x600000065600&gt;&#123;number = 1, name = main&#125;</div><div class="line">current thread: &lt;NSThread: 0x600000065600&gt;&#123;number = 1, name = main&#125;</div><div class="line">current thread: &lt;NSThread: 0x608000072040&gt;&#123;number = 3, name = (null)&#125;</div><div class="line">current thread: &lt;NSThread: 0x6000000706c0&gt;&#123;number = 5, name = (null)&#125;</div></pre></td></tr></table></figure>
<p>所以，如果NSBlockOperation封装的操作数大于1的时候,才会执行异步操作.不然也是在当前线程下执行的。</p>
<p>另外，NSOperation可以取消的，这个算是一大特色了，也是NSOperation的使用场景之一了。NSOperation有三种状态，isReady -&gt; isExecuting -&gt; isFinish， 如果在Ready的状态中对NSOperation进行取消，NSOperation会进入Finish状态。但是Operation已经开始执行了，就会一直运行到结束，或者由我们进行取消。也就是说Operation已经在executing状态，我们调用cancle方法系统不会中止线程的，这需要我们在任务过程中检测取消事件，并中止线程的执行，还要注意一点我们要释放内存或资源。</p>
<p>需要注意的是，调用cancel并不会退出线程，需要自行终止线程的运行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if (![operation isCancelled]) &#123;</div><div class="line">    [operation cancel];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>还有，NSOpertion可以设置优先级，从而改变其执行顺序，我们举个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">NSOperationQueue *queue = [[NSOperationQueue alloc] init];</div><div class="line">NSBlockOperation *operation1 = [NSBlockOperation blockOperationWithBlock:^&#123;</div><div class="line">    NSLog(@&quot;operation1后执行&quot;);</div><div class="line">&#125;];</div><div class="line">NSBlockOperation *operation2 = [NSBlockOperation blockOperationWithBlock:^&#123;</div><div class="line">    NSLog(@&quot;operation2先执行&quot;);</div><div class="line">&#125;];</div><div class="line">[operation1 addDependency:operation2];</div><div class="line">[queue addOperation:operation1];</div><div class="line">[queue addOperation:operation2];</div><div class="line"></div><div class="line">// 运行结果</div><div class="line">operation2先执行</div><div class="line">operation1后执行</div></pre></td></tr></table></figure>
<p>但是不能互相添加依赖，不然就死锁了，两个永远都不会执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[operation1 addDependency:operation2];</div><div class="line">[operation2 addDependency:operation1];</div></pre></td></tr></table></figure>
<p>有些时候，我们需要监听到任务完成后的回调事件，NSOperation也提供了这个方法，叫CompletionBlock。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">NSOperationQueue *queue = [[NSOperationQueue alloc] init];</div><div class="line">NSBlockOperation *operation1 = [NSBlockOperation blockOperationWithBlock:^&#123;</div><div class="line">    NSLog(@&quot;operation1执行&quot;);</div><div class="line">&#125;];</div><div class="line">[operation1 setCompletionBlock:^&#123;</div><div class="line">    NSLog(@&quot;operation1执行完毕&quot;);</div><div class="line">&#125;];</div><div class="line">NSBlockOperation *operation2 = [NSBlockOperation blockOperationWithBlock:^&#123;</div><div class="line">    NSLog(@&quot;operation2执行&quot;);</div><div class="line">&#125;];</div><div class="line">[operation2 setCompletionBlock:^&#123;</div><div class="line">    NSLog(@&quot;operation2执行完毕&quot;);</div><div class="line">&#125;];</div><div class="line">[queue addOperation:operation1];</div><div class="line">[queue addOperation:operation2];</div><div class="line"></div><div class="line">// 运行结果</div><div class="line">operation2执行</div><div class="line">operation1执行</div><div class="line">operation2执行完毕</div><div class="line">operation1执行完毕</div></pre></td></tr></table></figure>
<p>还有自定义NSOperation，由于不是经常能用到，所以就不多做介绍了。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>iOS多线程就总结到这里了，不过一般开发中用的GCD比较多，偶尔会用到NSOperation，这两个理解了就够用了，根据需求来定技术方案。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;小结第三篇，来总结总结iOS中多线程操作。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;多线程概述&quot;&gt;&lt;a href=&quot;#多线程概述&quot; class=&quot;headerlink&quot; title=&quot;多线程概述&quot;&gt;&lt;/a&gt;多线程概述&lt;/h3&gt;&lt;p&gt;对于ios系统中的某个App来讲，是单进程多线程方式来工作。一般来说，使用多线程的好处是可以把程序分成相对独立的几个模块，可以有效的防止某个模块堵塞的时候导致整个程序卡死；还有就是提高运行效率，现在CPU都是多核，多个核可以同时跑，可以同时执行多条线程。&lt;/p&gt;
&lt;p&gt;谈细节之前里，我们得说下有关多线程的几个概念。&lt;/p&gt;
&lt;h4 id=&quot;串行和并发&quot;&gt;&lt;a href=&quot;#串行和并发&quot; class=&quot;headerlink&quot; title=&quot;串行和并发&quot;&gt;&lt;/a&gt;串行和并发&lt;/h4&gt;&lt;p&gt;串行的意思是在多个任务下，每次只会有一个任务被执行，并发的意思是同一时间多个任务同时发生。并发是一种现象，解决并发现象的技术，叫做并行。我们经常说的多线程编程，说的就是并行技术，可以让多个CPU同时执行，加快执行速度，提高执行效率。&lt;/p&gt;
&lt;h4 id=&quot;同步和异步&quot;&gt;&lt;a href=&quot;#同步和异步&quot; class=&quot;headerlink&quot; title=&quot;同步和异步&quot;&gt;&lt;/a&gt;同步和异步&lt;/h4&gt;&lt;p&gt;同步的意思是在多任务中，一个任务只能等待另一个任务完成之后，他才可以进行，而异步的意思是一个任务的执行，不需要等待上一个任务的执行，不会发生堵塞。&lt;/p&gt;
&lt;h4 id=&quot;临界区&quot;&gt;&lt;a href=&quot;#临界区&quot; class=&quot;headerlink&quot; title=&quot;临界区&quot;&gt;&lt;/a&gt;临界区&lt;/h4&gt;&lt;p&gt;临界区是一种资源，这块资源不能并发执行，就叫做临界区。我们一般所看到的，临界区就是一个代码块。因为临界区资源如果可以被多个线程同时进行操作，比如读写，就可能出现异常。&lt;/p&gt;
&lt;h4 id=&quot;死锁&quot;&gt;&lt;a href=&quot;#死锁&quot; class=&quot;headerlink&quot; title=&quot;死锁&quot;&gt;&lt;/a&gt;死锁&lt;/h4&gt;&lt;p&gt;死锁就是指两条线程互相都在等待对方执行完毕，才能进入下一步操作。由于两条线程都不能执行下一步，所以造成死锁，卡住不动了。&lt;/p&gt;
&lt;h4 id=&quot;线程安全&quot;&gt;&lt;a href=&quot;#线程安全&quot; class=&quot;headerlink&quot; title=&quot;线程安全&quot;&gt;&lt;/a&gt;线程安全&lt;/h4&gt;&lt;p&gt;线程安全在iOS开发中应该听到多很多次，指的是在多线程中或者并发任务中可以被安全地调用，就称为线程安全。比如&lt;code&gt;NSDictionary&lt;/code&gt;就是线程安全的，可以在多线程中使用它，不会出现问题，而&lt;code&gt;NSMutableDictionary&lt;/code&gt;是线程不安全的，所以使用&lt;code&gt;NSMutableDictionary&lt;/code&gt;的时候应该保证每次只能有一个线程访问它。&lt;/p&gt;
&lt;h4 id=&quot;上下文切换&quot;&gt;&lt;a href=&quot;#上下文切换&quot; class=&quot;headerlink&quot; title=&quot;上下文切换&quot;&gt;&lt;/a&gt;上下文切换&lt;/h4&gt;&lt;p&gt;上下文切换指的是在一条进程中切换不同线程时，线程的等待和恢复执行的过程。这一过程中会带来一些额外的开销。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS小结之Runloop</title>
    <link href="http://yoursite.com/2017/06/11/iOS%E5%B0%8F%E7%BB%93%E4%B9%8BRunloop/"/>
    <id>http://yoursite.com/2017/06/11/iOS小结之Runloop/</id>
    <published>2017-06-11T07:34:03.000Z</published>
    <updated>2017-06-11T07:39:42.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>小结第二篇，来总结下Runloop的知识。</p>
</blockquote>
<h3 id="Runloop概述"><a href="#Runloop概述" class="headerlink" title="Runloop概述"></a>Runloop概述</h3><p>学过操作系统的同学都知道，一般来说，一条线程只能执行一个任务，当任务结束后，线程就会退出，完成使命。但是，在很多场景中，我们并不想让线程执行完任务就退出，往往，我们需要其保持随时随地听从命令，可以在需要的时候执行任务，不需要的时候处于等待状态。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function loop() &#123;</div><div class="line">    initLoop();</div><div class="line">    do &#123;</div><div class="line">        if(message_hasTask()) &#123;</div><div class="line">            message_execute(get_current_message());</div><div class="line">        &#125;</div><div class="line">    &#125; while (message != quit);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>比如，在手游上，我们需要一个模型来一直监听用户的触摸事件，来对游戏画面进行切换和逻辑判断。这种模型一般都具有相似性。比如：当模型被事件唤醒之后，如何快速地进行响应；当模型处于等待状态时，如何减少资源耗用等等。</p>
<p>这种模型，在iOS中称作Runloop。Runloop所解决的问题，就是实现一个线程，使得可以随时响应用户的事件，而不退出。</p>
<a id="more"></a>
<p>在iOS中，提供了两种有关的对象，一种是<code>NSRunLoop</code>，另外一种是<code>CFRunLoopRef</code>。<code>CFRunLoopRef</code>是基于<code>CoreFoundation</code>框架的，提供了纯C函数的API，所以这些API都是线程安全的。我们一般听到的<code>NSRunLoop</code>，是对<code>CFRunLoopRef</code>的封装，加上了面向对象的东西，所以这些API不是安全的。</p>
<p>所以，一般讲解<code>Runloop</code>的文章，其实都是在分析<code>CFRunLoopRef</code>这个东西。<code>CFRunLoopRef</code>的具体实现，苹果也将它开源了出来，可以在引用里看到其链接，这里就不再给出。</p>
<h3 id="Runloop和线程"><a href="#Runloop和线程" class="headerlink" title="Runloop和线程"></a>Runloop和线程</h3><p>上面可以看出，需要实现一个Runloop模型，是基于线程之上的。所以，Runloop和线程是息息相关的，在iOS系统中，Runloop属于线程的基础架构部分。每个线程，包括程序的主线程，都有与之的Runloop模型。</p>
<p>其实，Runloop和线程的绑定，是保存在一个全局的Dictionary中，线程和Runloop之间是一一对应的。当线程创建后，默认并不会启动Runloop，只有主动获取的时候，Runloop才会被创建，当线程结束后，对应的Runloop也会随之销毁。但是有个例外，就是主线程对应的Runloop默认是启动的。当程序启动的时候，会执行下面的函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">int main(int argc, char * argv[]) &#123;</div><div class="line">   @autoreleasepool &#123;</div><div class="line">       return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中，在<code>UIApplicationMain</code>内部帮我们开启了主线程的Runloop，相当于说，主线程的Runloop是默认启动的。这样我们才可以监听触摸事件、页面刷新等等功能。</p>
<h3 id="Runloop结构"><a href="#Runloop结构" class="headerlink" title="Runloop结构"></a>Runloop结构</h3><p>Runloop主要由5个类组成。如下所示：</p>
<ul>
<li>CFRunLoopRef</li>
<li>CFRunLoopModeRef</li>
<li>CFRunLoopSourceRef</li>
<li>CFRunLoopTimerRef</li>
<li>CFRunLoopObserverRef</li>
</ul>
<p>其关系如下图：</p>
<p><img src="http://blog.ibireme.com/wp-content/uploads/2015/05/RunLoop_0.png" alt="Runloop关系图"></p>
<p>一个Runloop包含多个Mode，每个Mode里面又包含多个Source/Timer/Observer。但是，需要注意的是，每次开启Runloop的时候，只会使用其中一个Mode，一般叫做currentMode。有时候实际场景中需要切换Mode，切换的时候，只能先退出Mode，然后再添加上新的Mode。</p>
<h4 id="Source0-和-Source1"><a href="#Source0-和-Source1" class="headerlink" title="Source0 和 Source1"></a>Source0 和 Source1</h4><p><strong>CFRunLoopSourceRef</strong>有两个版本：Source0和Source1，Source的作用是给线程发送异步事件。其中Source0是接收App内部的事件，比如用户点击滑动等事件，App自己负责处理，需要手动来唤醒Runloop，来处理这个事件；Source1是通过内核和其他线程发送消息用的，可以自动唤醒Runloop的线程。</p>
<h4 id="CFRunLoopTimerRef"><a href="#CFRunLoopTimerRef" class="headerlink" title="CFRunLoopTimerRef"></a>CFRunLoopTimerRef</h4><p>顾名思义，<strong>CFRunLoopTimerRef</strong>是基于时间来出发的，和NSTimer底层一样。当其加入到Runloop时，Runloop会注册对应的时间点，当时间点到时，Runloop会唤醒执行那个回调。常见的使用场景比如：延迟执行某个方法、CADisplayLink的使用等等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (void)performSelector:(SEL)aSelector withObject:(id)anArgument afterDelay:(NSTimeInterval)delay;</div><div class="line"></div><div class="line">+ (CADisplayLink *)displayLinkWithTarget:(id)target selector:(SEL)sel;</div></pre></td></tr></table></figure>
<h4 id="CFRunLoopObserverRef"><a href="#CFRunLoopObserverRef" class="headerlink" title="CFRunLoopObserverRef"></a>CFRunLoopObserverRef</h4><p><strong>CFRunLoopObserverRef</strong>是基于观察者模式，和<code>CFRunLoopTimerRef</code>类似，每个Observer都会包含有一个回调，用于监听Runloop的状态变化。可以监听到的状态变化有如下几个：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</div><div class="line">    kCFRunLoopEntry         = (1UL &lt;&lt; 0), // 即将进入Loop</div><div class="line">    kCFRunLoopBeforeTimers  = (1UL &lt;&lt; 1), // 即将处理 Timer</div><div class="line">    kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将处理 Source</div><div class="line">    kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), // 即将进入休眠</div><div class="line">    kCFRunLoopAfterWaiting  = (1UL &lt;&lt; 6), // 刚从休眠中唤醒</div><div class="line">    kCFRunLoopExit          = (1UL &lt;&lt; 7), // 即将退出Loop</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>上面所介绍的Source、Timer和Observer都可以添加到多个Model当中，但是如果在一个Mode当中添加多个，是不会起效果的，有一种特殊情况，就是当一个Mode里什么都没有，则这个Runloop就会直接退出。</p>
<h3 id="Runloop-Mode"><a href="#Runloop-Mode" class="headerlink" title="Runloop Mode"></a>Runloop Mode</h3><p>上面已经说过，Runloop的运行是基于特定的Mode，其数据结构如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">struct __CFRunLoopMode &#123;</div><div class="line">    CFStringRef _name;            // Mode Name, 例如 @&quot;kCFRunLoopDefaultMode&quot;</div><div class="line">    CFMutableSetRef _sources0;    // Set</div><div class="line">    CFMutableSetRef _sources1;    // Set</div><div class="line">    CFMutableArrayRef _observers; // Array</div><div class="line">    CFMutableArrayRef _timers;    // Array</div><div class="line">    ...</div><div class="line">&#125;;</div><div class="line"></div><div class="line">struct __CFRunLoop &#123;</div><div class="line">    CFMutableSetRef _commonModes;     // Set</div><div class="line">    CFMutableSetRef _commonModeItems; // Set&lt;Source/Observer/Timer&gt;</div><div class="line">    CFRunLoopModeRef _currentMode;    // Current Runloop Mode</div><div class="line">    CFMutableSetRef _modes;           // Set</div><div class="line">    ...</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这里需要注意一下，有一个很关键的属性叫<code>CommonModes</code>，每当 RunLoop 的内容发生变化时，RunLoop 都会自动将 _commonModeItems 里的 Source/Observer/Timer 同步到具有 “Common” 标记的所有Mode里。</p>
<p>在iOS系统中包含了两个Mode，一个是<code>NSDefaultRunLoopMode</code>和<code>UITrackingRunLoopMode</code>。这两个Mode都已经被注册成了CommonMode，一般App主线程的Runloop默认是<code>NSDefaultRunLoopMode</code>，当UIScrollView滑动的时候，Runloop就会退出，然后切换到<code>UITrackingRunLoopMode</code>。这两个是苹果公开的Mode，当然，还有一些私有Mode，就在这里不阐述了，有兴趣的读者可以Google一下。</p>
<p>出了上面这些，苹果还提供一个操作<code>CommonModes</code>的字符串，可以对所有CommonMode进行操作，叫做<code>kCFRunLoopCommonModes</code>，有些同学容易将这个东西和上面的Mode混淆，其实概念还是不一样的，<code>kCFRunLoopCommonModes</code>并不是一个新的Mode，在App主线程的Runloop中，是一个<code>CommonModes</code>组合，包含<code>NSDefaultRunLoopMode</code>和<code>UITrackingRunLoopMode</code>两种Mode。这里的话在下面NSTimer的应用场景中详细讲下。</p>
<h3 id="Runloop常见应用场景"><a href="#Runloop常见应用场景" class="headerlink" title="Runloop常见应用场景"></a>Runloop常见应用场景</h3><h4 id="AutoreleasePool"><a href="#AutoreleasePool" class="headerlink" title="AutoreleasePool"></a>AutoreleasePool</h4><p>AutoreleasePool其实和Runloop是有关系的，有一个经典的面试题是问<code>AutoreleasePool对象是什么时候释放的？</code>，什么答案都有，标准答案应该是AutoreleasePool对象应该是在当前Runloop迭代结束之后释放的。</p>
<p>当App启动之后，iOS会在主线程注册两个Observer，第一个Observer是监听即将进入Runloop的状态，监听到后，来创建AutoreleasePool对象，其优先级也是最高的，要保证创建AutoreleasePool发生在其他所有回调之前；第二个Observer是监听Runloop准备休眠状态，来释放旧的AutoreleasePool对象，并且创建新的AutoreleasePool对象以供使用，另外还需要监听即将退出Runloop的状态，优先级是最低的，以此来保证释放操作在其他所有回调之后。</p>
<p>所以，如果以后有人再问你<code>AutoreleasePool对象是什么时候释放的？</code>，一定要说这和Runloop有关系，当Runloop准备休眠的时候，会释放旧的AutoreleasePool对象，创建新的AutoreleasePool对象，当Runloop即将退出的时候，会释放掉相关所有的AutoreleasePool对象。</p>
<h4 id="NSTimer"><a href="#NSTimer" class="headerlink" title="NSTimer"></a>NSTimer</h4><p>NSTimer在时间点的触发，是基于Runloop运行的，使用NSTimer之前，都需要将其注册到Runloop上。其实NSTimer就是CFRunLoopTimerRef，一个NSTimer注册好之后，Runloop会自动在时间节点注册好事件。但是Runloop为了节省资源，并不会在非常准确的时间节点调用定时器。为此，NSTimer专门提供了一个tolerance属性，来设置宽容度，标记当时间节点到来之后，容许有多少误差可以触发回调。如果错过了某个时间节点，就只能等下一个时间节点的到来。</p>
<p>回到之前Mode的话题，当UISCrollView进行滚动的时候，NSTimer就无法正常工作，停止滑动又回恢复正常。这个原因是，添加到Runloop的NSTimer默认是以<code>NSDefaultRunLoopMode</code>模式在工作，当UIScrollView进行滑动的时候，Runloop会退出，然后切换到<code>UITrackingRunLoopMode</code>模式。由于NSTimer不是在这个模式下运行的，所以不会触发定时任务，无法工作。</p>
<p>要解决这个问题，我们就需要将NSTimer在<code>NSDefaultRunLoopMode</code>和<code>UITrackingRunLoopMode</code>两个模式下工作，在UIScrollView滑动的时候也可以进行触发定时任务。所以，我们需要使用到<code>kCFRunLoopCommonModes</code>来完成任务。一般使用如下语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];</div></pre></td></tr></table></figure>
<h4 id="事件响应和手势识别"><a href="#事件响应和手势识别" class="headerlink" title="事件响应和手势识别"></a>事件响应和手势识别</h4><p>事件响应其实和Runloop也是有关系的，为此，苹果专门注册了一个Source1用来接收系统事件。当手机的硬件发生感应，比如触摸、锁屏和摇晃，苹果注册的这个Source1都会收到回调，然后会将事件进行应用内部分发。</p>
<p>然后，App内主线程的Runloop会触发Source0事件，Source0收到回调进行下一步操作。</p>
<p>不同于事件响应，对于手势识别，收到苹果Source1对应用内部分发事件后，首先先将所有的手势回调打断，将所对应的UIGestureRecognizer事件标记为待处理，然后苹果会注册一个Observer来监听Runloop即将进入休眠的状态，然后在Observer回调里执行GestureRecognizer的回调。</p>
<h4 id="UI更新"><a href="#UI更新" class="headerlink" title="UI更新"></a>UI更新</h4><p>UI更新也和Runloop有关，当在操作UI时，改变了UI的大小、层次等，这个 UIView/CALayer就被标记为待处理，并被提交到一个全局的容器去。</p>
<p>苹果注册了一个Observer来监听Runloop即将进入休眠和即将退出的状态，然后在其Observer回调里遍历所有待处理的 UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面。</p>
<h4 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h4><p>GCD底层也和Runloop有关，当调用<code>dispatch_async(dispatch_get_main_queue(), block)</code>时，libDispatch会向主线程的RunLoop发送消息，RunLoop会被唤醒，并从消息中取得这个block，并在回调里执行这个block。但这个逻辑仅限于 dispatch 到主线程，dispatch 到其他线程仍然是由 libDispatch 处理的。</p>
<h4 id="PerformSelecter"><a href="#PerformSelecter" class="headerlink" title="PerformSelecter"></a>PerformSelecter</h4><p>PerformSelecter其实是创建了一个Timer，然后添加到当前的线程中。如果当前线程没有Runloop，这个方法则走不通的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (void)performSelector:(SEL)aSelector withObject:(nullable id)anArgument afterDelay:(NSTimeInterval)delay inModes:(NSArray&lt;NSRunLoopMode&gt; *)modes;</div><div class="line">- (void)performSelector:(SEL)aSelector withObject:(nullable id)anArgument afterDelay:(NSTimeInterval)delay;</div></pre></td></tr></table></figure>
<p>另外，还有AFNetworking2.0、NSURLConnection的使用其实都和Runloop有关，AFNetworking2.0希望能在后台线程接收到Delegate回调，单独创建了一条线程，并在这条这个线程中启动了Runloop。但是AFNetworking换成基于<code>NSURLSession</code>之后，并没有看到相关Runloop代码。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>有关Runloop的东西其实还有很多，这里只是站在大神的肩膀上，总结下基本的Runloop知识，希望能帮到需要的同学！</p>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><ul>
<li><p><a href="http://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="external">深入理解RunLoop</a></p>
</li>
<li><p><a href="http://opensource.apple.com/tarballs/CF/" target="_blank" rel="external">http://opensource.apple.com/tarballs/CF/</a></p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;小结第二篇，来总结下Runloop的知识。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;Runloop概述&quot;&gt;&lt;a href=&quot;#Runloop概述&quot; class=&quot;headerlink&quot; title=&quot;Runloop概述&quot;&gt;&lt;/a&gt;Runloop概述&lt;/h3&gt;&lt;p&gt;学过操作系统的同学都知道，一般来说，一条线程只能执行一个任务，当任务结束后，线程就会退出，完成使命。但是，在很多场景中，我们并不想让线程执行完任务就退出，往往，我们需要其保持随时随地听从命令，可以在需要的时候执行任务，不需要的时候处于等待状态。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;function loop() &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    initLoop();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    do &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        if(message_hasTask()) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            message_execute(get_current_message());&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125; while (message != quit);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;比如，在手游上，我们需要一个模型来一直监听用户的触摸事件，来对游戏画面进行切换和逻辑判断。这种模型一般都具有相似性。比如：当模型被事件唤醒之后，如何快速地进行响应；当模型处于等待状态时，如何减少资源耗用等等。&lt;/p&gt;
&lt;p&gt;这种模型，在iOS中称作Runloop。Runloop所解决的问题，就是实现一个线程，使得可以随时响应用户的事件，而不退出。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS小结之copy属性</title>
    <link href="http://yoursite.com/2017/06/05/iOS%E5%B0%8F%E7%BB%93%E4%B9%8Bcopy%E5%B1%9E%E6%80%A7/"/>
    <id>http://yoursite.com/2017/06/05/iOS小结之copy属性/</id>
    <published>2017-06-05T10:21:19.000Z</published>
    <updated>2017-06-11T07:38:25.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>一直都想去写个系列出来，总结出自己在日常开发中遇到过的知识点，时不时的回头看看，温故而知新。</p>
</blockquote>
<p>小结第一篇，来总结一下iOS开发中有关copy的知识点。</p>
<h3 id="iOS中，深拷贝和浅拷贝有什么不同？"><a href="#iOS中，深拷贝和浅拷贝有什么不同？" class="headerlink" title="iOS中，深拷贝和浅拷贝有什么不同？"></a>iOS中，深拷贝和浅拷贝有什么不同？</h3><h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h4><p>所谓的浅拷贝，就是指只是将对象内存地址多了一个引用，也就是说，拷贝结束之后，两个对象的值不仅相同，而且对象所指的内存地址都是一样的。</p>
<h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><p>所谓深拷贝，就是指拷贝一个对象的具体内容，拷贝结束之后，两个对象的值虽然是相同的，但是指向的内存地址是不同的。两个对象之间也互不影响，互不干扰。</p>
<h4 id="非集合类对象的copy和mutableCopy"><a href="#非集合类对象的copy和mutableCopy" class="headerlink" title="非集合类对象的copy和mutableCopy"></a>非集合类对象的copy和mutableCopy</h4><p>我们对一个NSString属性进行copy和mutableCopy。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">NSString *string = @&quot;abc&quot;;</div><div class="line">NSString *stringCopy = [string copy];</div><div class="line">NSMutableString *stringMCopy = [string mutableCopy];</div><div class="line"></div><div class="line">NSLog(@&quot;string: %p, %p&quot;, string, &amp;string);</div><div class="line">NSLog(@&quot;stringCopy: %p, %p&quot;, stringCopy, &amp;stringCopy);</div><div class="line">NSLog(@&quot;stringMCopy: %p, %p&quot;, stringMCopy, &amp;stringMCopy);</div></pre></td></tr></table></figure>
<p>运行之后，可以发现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">string: 0x1022fe078, 0x7fff5d901a48</div><div class="line">stringCopy: 0x1022fe078, 0x7fff5d901a40</div><div class="line">stringMCopy: 0x608000260240, 0x7fff5d901a38</div></pre></td></tr></table></figure>
<p>可以看出，对NSString进行copy操作，其新对象的内存地址并没有发生变化，改变的只仅仅是指针的地址，但是进行mutableCopy操作，其内存地址已经发生了变化，并且指针地址发生变化。我们将内存地址发生了变化的copy操作，称之为深拷贝，反之，内存地址没有发生了变化，称之为浅拷贝。</p>
<a id="more"></a>
<p>接下来，我们对NSMutableString进行copy和mutableCopy.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">NSMutableString *string = [NSMutableString stringWithFormat:@&quot;abc&quot;];</div><div class="line">NSString *stringCopy = [string copy];</div><div class="line">NSMutableString *stringMCopy = [string mutableCopy];</div><div class="line"></div><div class="line">NSLog(@&quot;string: %p, %p&quot;, string, &amp;string);</div><div class="line">NSLog(@&quot;stringCopy: %p, %p&quot;, stringCopy, &amp;stringCopy);</div><div class="line">NSLog(@&quot;stringMCopy: %p, %p&quot;, stringMCopy, &amp;stringMCopy);</div></pre></td></tr></table></figure>
<p>运行之后，我们可以发现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">string: 0x608000264680, 0x7fff5526aa48</div><div class="line">stringCopy: 0xa000000006362613, 0x7fff5526aa40</div><div class="line">stringMCopy: 0x608000264940, 0x7fff5526aa38</div></pre></td></tr></table></figure>
<p>对NSMutableString进行copy操作，其内存地址和指针地址都发生了变化，所以操作是深拷贝，和上面有所不同；进行mutableCopy操作，其内存地址和指针地址也都发生了变化，所以也是深拷贝。</p>
<blockquote>
<p>以上，我们可以得出，在非集合类对象中，对不可变对象进行copy操作，只仅仅是指针复制，进行mutableCopy操作，是内容复制。</p>
<p>对可变对象进行copy和mutableCopy操作，都是内容复制。</p>
</blockquote>
<h4 id="集合类对象的copy和mutableCopy"><a href="#集合类对象的copy和mutableCopy" class="headerlink" title="集合类对象的copy和mutableCopy"></a>集合类对象的copy和mutableCopy</h4><p>我们以NSArray为例，对其进行copy和mutableCopy操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">NSString *element_01 = @&quot;abc&quot;;</div><div class="line">NSString *element_02 = @&quot;def&quot;;</div><div class="line">NSString *element_03 = @&quot;ghi&quot;;</div><div class="line">NSArray *array = @[element_01, element_02, element_03];</div><div class="line">NSArray *arrayCopy = [array copy];</div><div class="line">NSMutableArray *arrayMCopy = [array mutableCopy];</div><div class="line"></div><div class="line">NSLog(@&quot;array: %p, %p; array.firstObject: %p&quot;, array, &amp;array, array.firstObject);</div><div class="line">NSLog(@&quot;arrayCopy: %p, %p; arrayCopy.firstObject: %p&quot;, arrayCopy, &amp;arrayCopy, arrayCopy.firstObject);</div><div class="line">NSLog(@&quot;arrayMCopy: %p, %p; arrayMCopy.firstObject: %p&quot;, arrayMCopy, &amp;arrayMCopy, arrayMCopy.firstObject);</div></pre></td></tr></table></figure>
<p>运行之后，结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">array: 0x600000245910, 0x7fff51367a10; array.firstObject: 0x10e898088</div><div class="line">arrayCopy: 0x600000245910, 0x7fff51367a08; arrayCopy.firstObject: 0x10e898088</div><div class="line">arrayMCopy: 0x600000245670, 0x7fff51367a00; arrayMCopy.firstObject: 0x10e898088</div></pre></td></tr></table></figure>
<p>可以发现，规律和非集合类的很像，对NSArray进行copy操作的时候，数组的内存地址没有发生变化，但是进行mutableCopy操作时，其内存地址发生了变化，结论跟非集合类的差不多。</p>
<p>但是，这里的深拷贝和非集合类的深拷贝还是不太一样的，上面我们打印出了数组的第一个元素的内存地址，可以发现，进行mutableCopy操作时，虽然数组内存地址发生了变化，但是数组元素的内存地址并没有发生变化。</p>
<p>这个属于一个特例，我们称它为<strong>单层深复制</strong>。并不是理论上的完全深复制。</p>
<p>接下来，我们以NSMutableArray为例，进行copy和mutableCopy操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">NSString *element_01 = @&quot;abc&quot;;</div><div class="line">NSString *element_02 = @&quot;def&quot;;</div><div class="line">NSString *element_03 = @&quot;ghi&quot;;</div><div class="line">NSMutableArray *array = [NSMutableArray arrayWithArray:@[element_01, element_02, element_03]];</div><div class="line"></div><div class="line">NSArray *arrayCopy = [array copy];</div><div class="line">NSMutableArray *arrayMCopy = [array mutableCopy];</div><div class="line"></div><div class="line">NSLog(@&quot;array: %p, %p; array.firstObject: %p&quot;, array, &amp;array, array.firstObject);</div><div class="line">NSLog(@&quot;arrayCopy: %p, %p; arrayCopy.firstObject: %p&quot;, arrayCopy, &amp;arrayCopy, arrayCopy.firstObject);</div><div class="line">NSLog(@&quot;arrayMCopy: %p, %p; arrayMCopy.firstObject: %p&quot;, arrayMCopy, &amp;arrayMCopy, arrayMCopy.firstObject);</div></pre></td></tr></table></figure>
<p>运行之后，结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">array: 0x6000000460c0, 0x7fff516d3a10; array.firstObject: 0x10e52c088</div><div class="line">arrayCopy: 0x600000046420, 0x7fff516d3a08; arrayCopy.firstObject: 0x10e52c088</div><div class="line">arrayMCopy: 0x600000046000, 0x7fff516d3a00; arrayMCopy.firstObject: 0x10e52c088</div></pre></td></tr></table></figure>
<p>可以看出，对NSMutableArray进行copy和mutableCopy操作，其内存地址都发生了变化，但是，对于数组中的元素，不管是进行的哪种操作，内存地址始终都没有发生变化，所以属于单层深拷贝。</p>
<blockquote>
<p>所以，我们可以得出，对于不可变的集合类对象进行copy操作，只是改变了指针，其内存地址并没有发生变化；进行mutableCopy操作，内存地址发生了变化，但是其中的元素内存地址并没有发生变化。</p>
<p>对于可变集合类对象，不管是进行copy操作还是mutableCopy操作，其内存地址都发生了变化，但是其中的元素内存地址都没有发生变化，属于单层深拷贝。</p>
</blockquote>
<h3 id="为什么我们声明NSString-NSArray或者NSDictionary的时候，经常使用copy关键字，使用strong有什么区别？"><a href="#为什么我们声明NSString-NSArray或者NSDictionary的时候，经常使用copy关键字，使用strong有什么区别？" class="headerlink" title="为什么我们声明NSString, NSArray或者NSDictionary的时候，经常使用copy关键字，使用strong有什么区别？"></a>为什么我们声明NSString, NSArray或者NSDictionary的时候，经常使用copy关键字，使用strong有什么区别？</h3><p>这种场景，在定义model时出现最多，首先我们先来看看用copy和strong有什么区别？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">/********************* test.h **********************/</div><div class="line">@interface test()</div><div class="line"></div><div class="line">@property (nonatomic, strong) NSString *strStrong;</div><div class="line">@property (nonatomic, copy) NSString *strCopy;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">/********************* test.m **********************/</div><div class="line">NSMutableString *string = [NSMutableString stringWithFormat:@&quot;abc&quot;];</div><div class="line">self.strStrong = string;</div><div class="line">self.strCopy = string;</div><div class="line">NSLog(@&quot;旧strStrong: %@&quot;, self.strStrong);</div><div class="line">NSLog(@&quot;旧strCopy: %@&quot;, self.strCopy);</div><div class="line"></div><div class="line">[string appendFormat:@&quot;def&quot;];</div><div class="line">NSLog(@&quot;新strStrong: %@&quot;, self.strStrong);</div><div class="line">NSLog(@&quot;新strCopy: %@&quot;, self.strCopy);</div></pre></td></tr></table></figure>
<p>运行之后，可以发现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">旧strStrong: abc</div><div class="line">旧strCopy: abc</div><div class="line">新strStrong: abcdef</div><div class="line">新strCopy: abc</div></pre></td></tr></table></figure>
<p>可以发现，当将一个可变对象分别赋值给两个使用不同修饰词的属性后，改变可变对象的内容，使用strong修饰的会跟随着改变，但使用copy修饰的没有改变内容。</p>
<p>知道了strong和copy修饰的区别之后，我们来看为什么要用copy？因为属性需要有封装性，当赋值之后，如果改变其值，会打破本有的封装，所以，在日常大部分开发工作中，我们需要使用copy来修饰NSString等。</p>
<p>那么，是不是NSMutableString等这些可变对象是不是也需要copy来修饰呢？答案是千万不要这么干，我们可以测试一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">/********************* test.h **********************/</div><div class="line">@interface test()</div><div class="line"></div><div class="line">@property (nonatomic, copy) NSMutableString *strCopy;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">/********************* test.m **********************/</div><div class="line">NSMutableString *string = [NSMutableString stringWithFormat:@&quot;abc&quot;];</div><div class="line">self.strCopy = string;</div><div class="line">[self.strCopy appendString:@&quot;def&quot;];</div></pre></td></tr></table></figure>
<p>运行上面代码，就会发现，在运行到最后一句的时候会崩溃，因为copy是复制出一个不可变的对象，在不可变对象上运行可变对象的方法，就会找不到执行方法，报下面的错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">reason: &apos;-[NSTaggedPointerString appendString:]: unrecognized selector sent to instance 0xa000000006362613&apos;</div></pre></td></tr></table></figure>
<h3 id="自定义对象实现copy"><a href="#自定义对象实现copy" class="headerlink" title="自定义对象实现copy"></a>自定义对象实现copy</h3><p>有时候，我们需要实现自定义的对象进行copy操作，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">/********************* CopyModel.h **********************/</div><div class="line">@interface CopyModel : NSObject</div><div class="line"></div><div class="line">@property (nonatomic, copy) NSString *title;</div><div class="line">@property (nonatomic, copy) NSString *name;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">/********************* ViewController.m **********************/</div><div class="line">CopyModel *model = [[CopyModel alloc] init];</div><div class="line">model.title = @&quot;title&quot;;</div><div class="line">model.name = @&quot;name&quot;;</div><div class="line"></div><div class="line">CopyModel *modelCopy = [model copy];</div></pre></td></tr></table></figure>
<p>但是，一运行我们发现直接崩溃了，报了一下错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">reason: &apos;-[CopyModel copyWithZone:]: unrecognized selector sent to instance 0x608000221c60&apos;</div></pre></td></tr></table></figure>
<p>可以看出，自定义对象实现copy操作，需要重写<code>copyWithZone</code>方法，我们修改下代码，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">/********************* CopyModel.h **********************/</div><div class="line">@interface CopyModel : NSObject</div><div class="line"></div><div class="line">@property (nonatomic, copy) NSString *title;</div><div class="line">@property (nonatomic, copy) NSString *name;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">/********************* CopyModel.m **********************/</div><div class="line">@implementation CopyModel</div><div class="line"></div><div class="line">- (instancetype)copyWithZone:(NSZone *)zone &#123;</div><div class="line">    CopyModel *copyModel = [[CopyModel allocWithZone:zone] init];</div><div class="line">    copyModel.title = self.title;</div><div class="line">    copyModel.name = self.name;</div><div class="line">    return copyModel;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">/********************* ViewController.m **********************/</div><div class="line">CopyModel *model = [[CopyModel alloc] init];</div><div class="line">model.title = @&quot;title&quot;;</div><div class="line">model.name = @&quot;name&quot;;</div><div class="line"></div><div class="line">CopyModel *modelCopy = [model copy];</div><div class="line">NSLog(@&quot;model: %p, %p&quot;, model, &amp;model);</div><div class="line">NSLog(@&quot;modelCopy: %p, %p&quot;, modelCopy, &amp;modelCopy);</div></pre></td></tr></table></figure>
<p>执行之后，可以发现并没有报错，并且copy也成功了。控制台打印如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">model: 0x608000037660, 0x7fff5bd62a48</div><div class="line">modelCopy: 0x60800003afa0, 0x7fff5bd62a40</div></pre></td></tr></table></figure>
<p>说明我们自定义对象copy成功了!</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这是当前遇到的有关copy问题的总结，应该还算挺全的，希望能帮助到需要的同学！</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;一直都想去写个系列出来，总结出自己在日常开发中遇到过的知识点，时不时的回头看看，温故而知新。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;小结第一篇，来总结一下iOS开发中有关copy的知识点。&lt;/p&gt;
&lt;h3 id=&quot;iOS中，深拷贝和浅拷贝有什么不同？&quot;&gt;&lt;a href=&quot;#iOS中，深拷贝和浅拷贝有什么不同？&quot; class=&quot;headerlink&quot; title=&quot;iOS中，深拷贝和浅拷贝有什么不同？&quot;&gt;&lt;/a&gt;iOS中，深拷贝和浅拷贝有什么不同？&lt;/h3&gt;&lt;h4 id=&quot;浅拷贝&quot;&gt;&lt;a href=&quot;#浅拷贝&quot; class=&quot;headerlink&quot; title=&quot;浅拷贝&quot;&gt;&lt;/a&gt;浅拷贝&lt;/h4&gt;&lt;p&gt;所谓的浅拷贝，就是指只是将对象内存地址多了一个引用，也就是说，拷贝结束之后，两个对象的值不仅相同，而且对象所指的内存地址都是一样的。&lt;/p&gt;
&lt;h4 id=&quot;深拷贝&quot;&gt;&lt;a href=&quot;#深拷贝&quot; class=&quot;headerlink&quot; title=&quot;深拷贝&quot;&gt;&lt;/a&gt;深拷贝&lt;/h4&gt;&lt;p&gt;所谓深拷贝，就是指拷贝一个对象的具体内容，拷贝结束之后，两个对象的值虽然是相同的，但是指向的内存地址是不同的。两个对象之间也互不影响，互不干扰。&lt;/p&gt;
&lt;h4 id=&quot;非集合类对象的copy和mutableCopy&quot;&gt;&lt;a href=&quot;#非集合类对象的copy和mutableCopy&quot; class=&quot;headerlink&quot; title=&quot;非集合类对象的copy和mutableCopy&quot;&gt;&lt;/a&gt;非集合类对象的copy和mutableCopy&lt;/h4&gt;&lt;p&gt;我们对一个NSString属性进行copy和mutableCopy。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;NSString *string = @&amp;quot;abc&amp;quot;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;NSString *stringCopy = [string copy];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;NSMutableString *stringMCopy = [string mutableCopy];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;NSLog(@&amp;quot;string: %p, %p&amp;quot;, string, &amp;amp;string);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;NSLog(@&amp;quot;stringCopy: %p, %p&amp;quot;, stringCopy, &amp;amp;stringCopy);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;NSLog(@&amp;quot;stringMCopy: %p, %p&amp;quot;, stringMCopy, &amp;amp;stringMCopy);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;运行之后，可以发现：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;string: 0x1022fe078, 0x7fff5d901a48&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;stringCopy: 0x1022fe078, 0x7fff5d901a40&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;stringMCopy: 0x608000260240, 0x7fff5d901a38&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;可以看出，对NSString进行copy操作，其新对象的内存地址并没有发生变化，改变的只仅仅是指针的地址，但是进行mutableCopy操作，其内存地址已经发生了变化，并且指针地址发生变化。我们将内存地址发生了变化的copy操作，称之为深拷贝，反之，内存地址没有发生了变化，称之为浅拷贝。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS中遍历的总结</title>
    <link href="http://yoursite.com/2017/04/20/iOS%E4%B8%AD%E9%81%8D%E5%8E%86%E7%9A%84%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2017/04/20/iOS中遍历的总结/</id>
    <published>2017-04-20T13:15:11.000Z</published>
    <updated>2017-06-11T07:38:29.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="遍历的种类"><a href="#遍历的种类" class="headerlink" title="遍历的种类"></a>遍历的种类</h3><p>在iOS开发中，可以使用多种方法进行元素遍历，具体有一下几种：</p>
<h4 id="经典for循环"><a href="#经典for循环" class="headerlink" title="经典for循环"></a>经典for循环</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">NSArray *iosArray = @[@&quot;a&quot;, @&quot;b&quot;, @&quot;c&quot;, @&quot;d&quot;, @&quot;e&quot;, @&quot;f&quot;, @&quot;g&quot;];</div><div class="line">for (int i = 0; i &lt; iosArray.count; i++) &#123;</div><div class="line">    //处理数组中数据</div><div class="line">    NSLog(@&quot;%@&quot;, iosArray[i]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="NSEnumerator遍历"><a href="#NSEnumerator遍历" class="headerlink" title="NSEnumerator遍历"></a>NSEnumerator遍历</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">NSArray *iosArray = @[@&quot;a&quot;, @&quot;b&quot;, @&quot;c&quot;, @&quot;d&quot;, @&quot;e&quot;, @&quot;f&quot;, @&quot;g&quot;];</div><div class="line">NSEnumerator *enumerator = [iosArray objectEnumerator];//正向遍历</div><div class="line">// NSEnumerator *enumerator = [iosArray reverseObjectEnumerator];//反向遍历</div><div class="line"></div><div class="line">id object;</div><div class="line"></div><div class="line">while ((object = [enumerator nextObject]) != nil) &#123;</div><div class="line">    //处理枚举器中的数据</div><div class="line">    NSLog(@&quot;%@&quot;, object);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<h4 id="for-in快速遍历"><a href="#for-in快速遍历" class="headerlink" title="for-in快速遍历"></a>for-in快速遍历</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">NSArray *iosArray = @[@&quot;a&quot;, @&quot;b&quot;, @&quot;c&quot;, @&quot;d&quot;, @&quot;e&quot;, @&quot;f&quot;, @&quot;g&quot;];</div><div class="line">for (NSString *obj in iosArray) &#123;</div><div class="line">    //处理数组中的数据</div><div class="line">    NSLog(@&quot;%@&quot;, obj);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="EnumeratorBlock遍历"><a href="#EnumeratorBlock遍历" class="headerlink" title="EnumeratorBlock遍历"></a>EnumeratorBlock遍历</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">NSArray *iosArray = @[@&quot;a&quot;, @&quot;b&quot;, @&quot;c&quot;, @&quot;d&quot;, @&quot;e&quot;, @&quot;f&quot;, @&quot;g&quot;];</div><div class="line">[iosArray enumerateObjectsUsingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123;</div><div class="line">    NSLog(@&quot;%@&quot;, obj);</div><div class="line">    if ([obj isEqualToString:@&quot;e&quot;]) &#123;</div><div class="line">        *stop = YES;    // 跳出遍历</div><div class="line">    &#125;</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>另外，EnumeratorBlock还支持反向遍历，并发遍历，并发遍历可以使用多核的优化，充分利用系统的资源。</p>
<h4 id="反向遍历"><a href="#反向遍历" class="headerlink" title="反向遍历"></a>反向遍历</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">NSArray *iosArray = @[@&quot;a&quot;, @&quot;b&quot;, @&quot;c&quot;, @&quot;d&quot;, @&quot;e&quot;, @&quot;f&quot;, @&quot;g&quot;];</div><div class="line">[iosArray enumerateObjectsWithOptions:NSEnumerationReverse usingBlock:^(NSString *obj, NSUInteger idx, BOOL * _Nonnull stop) &#123;</div><div class="line">    NSLog(@&quot;%@&quot;, obj);</div><div class="line">    if ([obj isEqualToString:@&quot;e&quot;]) &#123;</div><div class="line">        *stop = YES;</div><div class="line">    &#125;</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<h4 id="并发遍历"><a href="#并发遍历" class="headerlink" title="并发遍历"></a>并发遍历</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">NSArray *iosArray = @[@&quot;a&quot;, @&quot;b&quot;, @&quot;c&quot;, @&quot;d&quot;, @&quot;e&quot;, @&quot;f&quot;, @&quot;g&quot;];</div><div class="line">NSMutableArray *iosMutableArray = [NSMutableArray arrayWithArray:iosArray];</div><div class="line">[iosMutableArray enumerateObjectsWithOptions:NSEnumerationConcurrent usingBlock:^(NSString *obj, NSUInteger idx, BOOL * _Nonnull stop) &#123;</div><div class="line">    obj = [NSString stringWithFormat:@&quot;_%@&quot;, obj];</div><div class="line">    [iosMutableArray replaceObjectAtIndex:idx withObject:obj];</div><div class="line">    NSLog(@&quot;%@&quot;, obj);</div><div class="line"></div><div class="line">    if ([obj isEqualToString:@&quot;_I&quot;]) &#123;</div><div class="line">        *stop = YES;</div><div class="line">    &#125;</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<h4 id="dispatch-apply遍历"><a href="#dispatch-apply遍历" class="headerlink" title="dispatch_apply遍历"></a>dispatch_apply遍历</h4><p>dispatch_apply类似于for循环，这里需要注意的是，dispatch_apple是同步调用，调用完毕返回结果，并且由于是GCD实现，所以可以使用并发队列或者是串行队列。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;queue&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class="line">//    dispatch_queue_t queue = dispatch_queue_create(&quot;queue&quot;, DISPATCH_QUEUE_SERIAL); // 串行队列</div><div class="line">dispatch_apply(array.count, queue, ^(size_t i) &#123;</div><div class="line">    Enumerate *enumerate = [array objectAtIndex:i];</div><div class="line">    NSLog(@&quot;number: %ld&quot;, enumerate.number);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="遍历的注意事项"><a href="#遍历的注意事项" class="headerlink" title="遍历的注意事项"></a>遍历的注意事项</h3><h4 id="for循环中不要修改数组"><a href="#for循环中不要修改数组" class="headerlink" title="for循环中不要修改数组"></a>for循环中不要修改数组</h4><p>遍历过程中是不能随便删除遍历的元素的，如果需要删除元素，可以先复制一份出来，比如如下的代码会有问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">NSMutableArray *iosArray = @[@&quot;a&quot;, @&quot;b&quot;, @&quot;c&quot;, @&quot;d&quot;, @&quot;e&quot;, @&quot;f&quot;, @&quot;g&quot;];</div><div class="line">for (NSString *obj in iosArray) &#123;</div><div class="line">    //处理数组中的数据</div><div class="line">    if([@&quot;e&quot; isEqualTo:obj]) &#123;</div><div class="line">        [iosArray removeObject:obj];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是使用enumerateBlock可以在block内部做removeObject操作，原因应该是和Block的特性有关，<strong>在Block中会保存变量的值，而不会随变量的值的改变而改变</strong>。</p>
<h4 id="遍历的速率"><a href="#遍历的速率" class="headerlink" title="遍历的速率"></a>遍历的速率</h4><p>当数组容量很大的时候，如果只是进行数组遍历的话，使用for-in是最快速的，其次是并发遍历，这个很多人都以为enumerateBlock是最快的。</p>
<h3 id="遍历实践tips"><a href="#遍历实践tips" class="headerlink" title="遍历实践tips"></a>遍历实践tips</h3><h4 id="数组分组"><a href="#数组分组" class="headerlink" title="数组分组"></a>数组分组</h4><p>在开发中，有时需要对数组进行某种情况的分组，比如，一个拥有很多消息模型的数组，我们需要根据消息的创建月份进行分组，那么可以使用下面的方法实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">NSMutableSet *set=[NSMutableSet set];</div><div class="line">NSArray *array = @[message1, message2, message3, message4, message5, message6, message7];</div><div class="line">__block NSArray *tempDataArray = [NSArray arrayWithArray:array];</div><div class="line">[tempDataArray enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) &#123;</div><div class="line">    [set addObject:obj.month];//利用set不重复的特性,得到有多少组,根据数组中消息的月份属性</div><div class="line">&#125;];</div><div class="line">[set enumerateObjectsUsingBlock:^(id obj, BOOL *stop) &#123;//遍历set数组</div><div class="line">    NSPredicate *predicate = [NSPredicate predicateWithFormat:@&quot;SELF.month = %@&quot;, obj];//创建谓词筛选器</div><div class="line">    NSArray *group = [tempDataArray filteredArrayUsingPredicate:predicate];//用数组的过滤方法得到新的数组,在添加的最终的数组</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="倒序遍历"><a href="#倒序遍历" class="headerlink" title="倒序遍历"></a>倒序遍历</h4><p>倒序遍历也很常见，可以使用上面的反向遍历来实现。</p>
<h4 id="set排序"><a href="#set排序" class="headerlink" title="set排序"></a>set排序</h4><p>这个和Emunerate其实没有关系，但是也很实用，我们知道set是无序的，但是有时需要实现有顺序的set，可以使用下面来实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">//由于set无序，现将set转换成nsarray</div><div class="line">NSArray *sortDescriptor = @[[[NSSortDescriptor alloc] initWithKey:@&quot;self&quot; ascending:NO]];</div><div class="line">NSArray *sortSetArray = [set sortedArrayUsingDescriptors:sortDescriptor];</div></pre></td></tr></table></figure>
<p>其实原理是将set转化成array来实现的。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>遍历在我们日常开发中十分常见，根据应用场景，选择合适的遍历方法才是我们需要关系的。这篇文章总结了下遍历的种类和注意事项，希望能帮助到有需要的同学。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;遍历的种类&quot;&gt;&lt;a href=&quot;#遍历的种类&quot; class=&quot;headerlink&quot; title=&quot;遍历的种类&quot;&gt;&lt;/a&gt;遍历的种类&lt;/h3&gt;&lt;p&gt;在iOS开发中，可以使用多种方法进行元素遍历，具体有一下几种：&lt;/p&gt;
&lt;h4 id=&quot;经典for循环&quot;&gt;&lt;a href=&quot;#经典for循环&quot; class=&quot;headerlink&quot; title=&quot;经典for循环&quot;&gt;&lt;/a&gt;经典for循环&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;NSArray *iosArray = @[@&amp;quot;a&amp;quot;, @&amp;quot;b&amp;quot;, @&amp;quot;c&amp;quot;, @&amp;quot;d&amp;quot;, @&amp;quot;e&amp;quot;, @&amp;quot;f&amp;quot;, @&amp;quot;g&amp;quot;];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;for (int i = 0; i &amp;lt; iosArray.count; i++) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    //处理数组中数据&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    NSLog(@&amp;quot;%@&amp;quot;, iosArray[i]);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;NSEnumerator遍历&quot;&gt;&lt;a href=&quot;#NSEnumerator遍历&quot; class=&quot;headerlink&quot; title=&quot;NSEnumerator遍历&quot;&gt;&lt;/a&gt;NSEnumerator遍历&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;NSArray *iosArray = @[@&amp;quot;a&amp;quot;, @&amp;quot;b&amp;quot;, @&amp;quot;c&amp;quot;, @&amp;quot;d&amp;quot;, @&amp;quot;e&amp;quot;, @&amp;quot;f&amp;quot;, @&amp;quot;g&amp;quot;];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;NSEnumerator *enumerator = [iosArray objectEnumerator];//正向遍历&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;// NSEnumerator *enumerator = [iosArray reverseObjectEnumerator];//反向遍历&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;id object;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;while ((object = [enumerator nextObject]) != nil) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    //处理枚举器中的数据&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    NSLog(@&amp;quot;%@&amp;quot;, object);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>MQTT协议及推送服务</title>
    <link href="http://yoursite.com/2017/04/02/MQTT%E5%8D%8F%E8%AE%AE%E5%8F%8A%E6%8E%A8%E9%80%81%E6%9C%8D%E5%8A%A1/"/>
    <id>http://yoursite.com/2017/04/02/MQTT协议及推送服务/</id>
    <published>2017-04-02T13:31:07.000Z</published>
    <updated>2017-06-11T07:38:32.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="MQTT简介"><a href="#MQTT简介" class="headerlink" title="MQTT简介"></a>MQTT简介</h3><p>MQTT全称叫做Message Queuing Telemetry Transport，意为消息队列遥测传输，是IBM开发的一个即时通讯协议。由于其维护一个长连接以轻量级低消耗著称，所以常用于移动端消息推送服务开发。</p>
<h4 id="MQTT特性"><a href="#MQTT特性" class="headerlink" title="MQTT特性"></a>MQTT特性</h4><p>MQTT具有如下特性：</p>
<ul>
<li>使用发布／订阅消息模式，提供一对多消息发布；</li>
<li>对负载内容屏蔽的消息传输；</li>
<li><p>使用TCP/IP进行网络连接；</p>
<p>  主流的MQTT是基于TCP进行连接的，同样也有UDP版本的MQTT，但是不太常用，叫做MQTT-SN。</p>
</li>
<li><p>具有三种消息发布服务质量选项；</p>
<ol>
<li>“至多一次”，通常app的推送使用的就是这种模式。也就是说，如果移动设备在消息推送的时候没有联网，那么再次联网就不会收到通知了；</li>
<li>“至少一次”，可以确保消息收到，但消息可能会重复；</li>
<li>“只有一次”，确保消息到达一次，比如计费系统， 如果出现消息重复或者丢失会导致系统结果不正确的问题。</li>
</ol>
</li>
<li><p>小型传输，开销很小（固定长度的头部是2字节），协议交换最小化，以降低网络流量；</p>
<p>  这就是为什么MQTT能以轻量级低消耗著称，所以MQTT特别适用于低开销、低宽带占用的即时通讯场景。</p>
</li>
<li><p>通知有关各方客户端异常中断的机制。</p>
</li>
</ul>
<a id="more"></a>
<h4 id="MQTT协议实现方式"><a href="#MQTT协议实现方式" class="headerlink" title="MQTT协议实现方式"></a>MQTT协议实现方式</h4><p><img src="https://itbilu.com/upload/2016/1/9/14523188625918865.png" alt="image"></p>
<p>在MQTT协议中有三种身份：</p>
<ul>
<li>发布者(Publish)。发布者其实是客户端，可以进行发布消息；<ul>
<li>代理(Broker)。代理指的是服务器，比较有名的是eqmtt，当前，你也可以用其他成熟的框架去搭建MQTT服务；</li>
<li>订阅者(Subscribe)。一般指的是客户端，不过，发布者同时也可以是订阅者。</li>
</ul>
</li>
</ul>
<h4 id="MQTT客户端"><a href="#MQTT客户端" class="headerlink" title="MQTT客户端"></a>MQTT客户端</h4><p>一般来说，客户端可以实现一下功能：</p>
<ul>
<li>给其他客户端发布订阅的信息；</li>
<li>订阅其他客户端发布的信息；</li>
<li>退订和订阅主题；</li>
<li>断开服务器连接。</li>
</ul>
<h4 id="MQTT服务端"><a href="#MQTT服务端" class="headerlink" title="MQTT服务端"></a>MQTT服务端</h4><p>MQTT服务端也称为消息代理，经常你会听到broker这个词。它可以实现一下功能：</p>
<ul>
<li>接收来自客户端的网络连接；</li>
<li>接受客户发布的应用信息；</li>
<li>处理来自客户端主题订阅和退订请求；</li>
<li>向订阅的客户端转发应用程序消息。</li>
</ul>
<h4 id="MQTT协议中的方法"><a href="#MQTT协议中的方法" class="headerlink" title="MQTT协议中的方法"></a>MQTT协议中的方法</h4><p>MQTT和HTTP一样，也定义了一些动作，来表示对确定资源进行操作。</p>
<ul>
<li><strong>Connect</strong>，等待于服务器建立连接；</li>
<li><strong>Disconnect</strong>，等待客户端完成所做的工作，并与服务器断开TCP/IP会话；</li>
<li><strong>Subscribe</strong>，主题订阅；</li>
<li><strong>UnSubscribe</strong>，主题取消订阅；</li>
<li><strong>Publish</strong>，发送消息。</li>
</ul>
<h3 id="移动端推送服务"><a href="#移动端推送服务" class="headerlink" title="移动端推送服务"></a>移动端推送服务</h3><p>消息推送服务目前已经是app开发中必备的一个功能了，及时地将消息推送给用户，可以使得用户不会错过重大新闻或者重要事件通知。一般，推送服务有三种实现方式：</p>
<ol>
<li>轮询方式。客户端不断的查询服务器，检索新内容。这种方式的缺点十分明显，如果轮询频率过快，会大量消耗网络带宽和电池；</li>
<li>长连接方式。客户端和服务端维持一条TCP/IP长连接，服务端向客户端push数据。这种方式可以避免轮询方式带来的性能问题，但是长连接依然会带来耗能问题。目前苹果的APNS和谷歌的GCM都是基于此方案来实现推送服务的；</li>
<li>SMS方式。当服务端有新内容的时候，会发送一条类似短信的指令传给客户端，客户端收到后从服务端下载新内容。由于运营商并没有免费开放这种指令，使用需要向运营商缴纳部分费用，所以并没有大量运用起来，但是这种方式非常的高效和及时。</li>
</ol>
<h4 id="iOS和Andorid推送的实现差异"><a href="#iOS和Andorid推送的实现差异" class="headerlink" title="iOS和Andorid推送的实现差异"></a>iOS和Andorid推送的实现差异</h4><p>之前我们说过，目前移动端的推送服务实现都是基于长连接方式实现的。服务端和客户端之间需要存在一条长连接来维持，当服务端主动推送内容给客户端时，客户端可以接收到该内容。</p>
<p><strong>iOS推送服务</strong></p>
<p>在iOS系统中，这个长连接是由系统去维护，iOS上所有应用的推送都是先将推送推到苹果推送服务器(APNs)上，应用需要推送功能时，需要先注册推送服务。其流程图如下所示：</p>
<p><img src="https://pic4.zhimg.com/f74c97ee64f0bf008e8c790206811f4f_b.png" alt="推送注册流程图"></p>
<p>首先，苹果会下发deviceToken，这是APNs推送实现的基础。APNs推送能够实现就是基于deviceToken来推送的，只有正确的deviceToken才会被APNs接受，一般第三方推送商就是来收集deviceToken来进行推送的。</p>
<p>当开始进行推送内容的时候，服务端会将内容先推到APNs，然后，剩下的就都交给APNs去做了，其推送内容流程如下：</p>
<p><img src="https://pic2.zhimg.com/4525ca70963895ab4fca064a537dbcd9_b.png" alt="推送注册流程图"></p>
<p>苹果这么做，不管是给用户还是开发者，带来的好处都是实实在在的：</p>
<ol>
<li>由于是系统级别的长连接，所以不会出现被杀死而不发推送的现象；</li>
<li>省电。不用每个app都去各自维护一个自己的长连接；</li>
<li>安全可靠。为了能够使用推送服务，必须先在开发者账号注册推送功能，这就大大降低了长连接滥用的场景。</li>
<li>对于开发来说，实现起来十分容易，服务端只要将正确的deviceToken和推送内容发送给APNs，然后客户端进行推送注册和逻辑处理就行了。</li>
</ol>
<p><strong>Android推送服务</strong></p>
<p>Android系统上，Google也推出了和APNS类似的服务，叫做GCM。但是由于国情原因(你懂得)，导致该服务在中国无法使用。所以，国内Andorid的普遍做法是自己维护一条长连接，和自己的推送服务器或者第三方推送商对接。</p>
<p>其实现原理APNs没有本质区别，但是由于一个设备通常需要维持多个长连接，所以在耗能这块，Andorid这块处理就不尽人意，并且，由于后台可以常驻，所以安全性这块也得不到保障。</p>
<p>除了类似APNs的实现，在Android上，也可以采用轮询方式，也可以简单实现推送功能。</p>
<h3 id="MQTT实现消息推送"><a href="#MQTT实现消息推送" class="headerlink" title="MQTT实现消息推送"></a>MQTT实现消息推送</h3><h4 id="iOS端实现"><a href="#iOS端实现" class="headerlink" title="iOS端实现"></a>iOS端实现</h4><p>对于iOS端使用MQTT来实现消息推送服务，比较常见的做法就是采用离线消息的方式去做，服务端发送推送消息，发送到APNs上，然后APNs通知客户端收到通知消息，客户端去服务端拉取最新消息列表，然后展示的界面上并处理相关逻辑。</p>
<h4 id="Android端实现"><a href="#Android端实现" class="headerlink" title="Android端实现"></a>Android端实现</h4><p>由于并不是做Android开发，并且Android方面采用方式五花八门，了解的做法是类似iOS的实现，利用MQTT将服务端和客户端建议一个长连接，然后服务端将消息直接推倒客户端上，客户端收到推送消息后，去服务端拉取最新的消息列表。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>对于移动设备来说，MQTT以低开销、低带宽著称，十分适合搭建推送服务。目前方案也比较成熟，希望未来MQTT的应用会越来越广！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;MQTT简介&quot;&gt;&lt;a href=&quot;#MQTT简介&quot; class=&quot;headerlink&quot; title=&quot;MQTT简介&quot;&gt;&lt;/a&gt;MQTT简介&lt;/h3&gt;&lt;p&gt;MQTT全称叫做Message Queuing Telemetry Transport，意为消息队列遥测传输，是IBM开发的一个即时通讯协议。由于其维护一个长连接以轻量级低消耗著称，所以常用于移动端消息推送服务开发。&lt;/p&gt;
&lt;h4 id=&quot;MQTT特性&quot;&gt;&lt;a href=&quot;#MQTT特性&quot; class=&quot;headerlink&quot; title=&quot;MQTT特性&quot;&gt;&lt;/a&gt;MQTT特性&lt;/h4&gt;&lt;p&gt;MQTT具有如下特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用发布／订阅消息模式，提供一对多消息发布；&lt;/li&gt;
&lt;li&gt;对负载内容屏蔽的消息传输；&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用TCP/IP进行网络连接；&lt;/p&gt;
&lt;p&gt;  主流的MQTT是基于TCP进行连接的，同样也有UDP版本的MQTT，但是不太常用，叫做MQTT-SN。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;具有三种消息发布服务质量选项；&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;“至多一次”，通常app的推送使用的就是这种模式。也就是说，如果移动设备在消息推送的时候没有联网，那么再次联网就不会收到通知了；&lt;/li&gt;
&lt;li&gt;“至少一次”，可以确保消息收到，但消息可能会重复；&lt;/li&gt;
&lt;li&gt;“只有一次”，确保消息到达一次，比如计费系统， 如果出现消息重复或者丢失会导致系统结果不正确的问题。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;小型传输，开销很小（固定长度的头部是2字节），协议交换最小化，以降低网络流量；&lt;/p&gt;
&lt;p&gt;  这就是为什么MQTT能以轻量级低消耗著称，所以MQTT特别适用于低开销、低宽带占用的即时通讯场景。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;通知有关各方客户端异常中断的机制。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>有关Keychain服务，你需要了解这些</title>
    <link href="http://yoursite.com/2017/02/20/%E6%9C%89%E5%85%B3Keychain%E6%9C%8D%E5%8A%A1%EF%BC%8C%E4%BD%A0%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E8%BF%99%E4%BA%9B/"/>
    <id>http://yoursite.com/2017/02/20/有关Keychain服务，你需要了解这些/</id>
    <published>2017-02-20T06:15:44.000Z</published>
    <updated>2017-06-11T07:38:22.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>在iOS系统中，Keychain提供了安全的存储服务，用来存储一些敏感信息。但是在日常开发中，我们经常会忽视这个苹果自荐的功能，本文的目的就是引起开发者的重视，敏感信息尽量使用Keychain服务。</p>
</blockquote>
<h3 id="NSUserDefaults不安全"><a href="#NSUserDefaults不安全" class="headerlink" title="NSUserDefaults不安全"></a>NSUserDefaults不安全</h3><p>NSUserDefaults其实是plist文件中键值存储，并且最大的问题是存在与沙盒中，这就对安全性埋下了隐患。如果攻击者破解app，拿到了沙盒中的数据，就会造成数据泄漏，后果不堪设想。</p>
<p>当然，一般也不会有把密码直接使用NSUserDefaults存储的，都会进行加密、或者是多重加密后再进行NSUserDefaults存储。这么做其实是可行的，前提是加密算法不能泄漏。有个小问题就是，如果用户删掉app重装的话，之前所有存储的敏感信息都会消失。比如，一个用户误删了使用NSUserDefaults存储密码的app，当重新安装之后，由于以前是记住密码免登录，只因为自己操作不当，接下来要进入找回密码功能，重新修改密码才能再次使用app。这对用户来说是一种相当不友好的体验。</p>
<p>所以，正确的姿势是使用Keychain服务来存储。Keychain保存的数据不仅仅是加密过的，而且由于Keychain是存在与沙盒之外的，当应用删除之后，app存储的数据并没有被删掉，第二次安装时只要读取Keychain里的数据，即可得到以前存储的信息。</p>
<a id="more"></a>
<h3 id="Keychain使用场景"><a href="#Keychain使用场景" class="headerlink" title="Keychain使用场景"></a>Keychain使用场景</h3><h4 id="存储隐私信息"><a href="#存储隐私信息" class="headerlink" title="存储隐私信息"></a>存储隐私信息</h4><p>在iOS系统中，最常用的keychain服务就是存储用户密码了。使用keychain保存用户密码最大的好处已经在上面说过，个人极力推荐这么做。</p>
<h4 id="数据共享"><a href="#数据共享" class="headerlink" title="数据共享"></a>数据共享</h4><p>如果我们有多个app，它们之间需要共享一些数据，以提供更好的用户体验，那么使用Keychain群组可以实现。但前提是同一个公司的产品才能共享，比如<code>com.hyyy.test1</code>和<code>com.hyyy.test2</code>两个同一公司下的不同产品之前可以实现数据共享。</p>
<h4 id="设备唯一标示存储"><a href="#设备唯一标示存储" class="headerlink" title="设备唯一标示存储"></a>设备唯一标示存储</h4><p>在iOS中，为了在苹果的打压下获取唯一标示符，开发者们也是想尽了办法，目前最好的方式就是获取IDFV，并将其存储到keychain中。IDFV是设备区别应用提供商的，一般来说可以作为应用唯一标示符。但是IDFV缺陷就是当设备删除了该所有应用提供商的app之后，IDFV值会发生变化，所以IDFV+Keychain的组合目前被经常用到，来替代UDID的作用。特别是加上Keychain的共享服务，可以使应用提供商下的所有app下获取的IDFV都不会发生变化。这一服务可以说是目前最佳的识别用户的办法。</p>
<h4 id="其他用处"><a href="#其他用处" class="headerlink" title="其他用处"></a>其他用处</h4><p>当然，不同app的需求是不一样的，如果你需要存储一些信息，即使app删掉后也不会丢失，那么使用Keychain服务可以完美地实现这点。</p>
<h3 id="实践总结"><a href="#实践总结" class="headerlink" title="实践总结"></a>实践总结</h3><p>其实，所有的这些都是本人摸索出来的，并且实现了一个Swift3下的简单Keychain工具，叫<a href="https://github.com/castial/HYKeychainHelper" target="_blank" rel="external">HYKeychainHelper</a>。这个框架是参考大名鼎鼎的<a href="https://github.com/soffes/SAMKeychain" target="_blank" rel="external">SAMKeychain</a>和苹果官方的GenericKeychain实现的，如果您的Swfit项目需要使用到Keychain，希望这个可以帮到您，HYKeychainHelper操作起来也比较简单，如果您之前使用过SAMKeychain的话，那更容易了。</p>
<p><a href="https://github.com/castial/HYKeychainHelper" target="_blank" rel="external">HYKeychainHelper</a>的用法也比较简单，为了更好上手，语法采用和<a href="https://github.com/soffes/SAMKeychain" target="_blank" rel="external">SAMKeychain</a>基本一致。具体如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">/// query account&apos;s password</div><div class="line"></div><div class="line">HYKeychainHelper.password(service: &quot;your_service_name&quot;, account: &quot;your_account_name&quot;)</div><div class="line"></div><div class="line">/// add or update an account</div><div class="line"></div><div class="line">HYKeychainHelper.set(password: &quot;your_password&quot;, service: &quot;your_service_name&quot;, account: &quot;your_account_name&quot;)</div><div class="line"></div><div class="line">/// delete an account</div><div class="line"></div><div class="line">HYKeychainHelper.deletePassword(service: &quot;your_service_name&quot;, account: &quot;your_account_name&quot;)</div><div class="line"></div><div class="line">/// all accounts</div><div class="line"></div><div class="line">HYKeychainHelper.allAccounts(forService: &quot;your_service_name&quot;)</div></pre></td></tr></table></figure>
<blockquote>
<p>对于更多的用法，请查看HYKeychainHelper获取更多细节。</p>
</blockquote>
<p>另外，对Keychain的了解难免有些遗漏，如果对Keychain有更多的看法，欢迎留言给我，对自己来说也是一种收获！</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在iOS系统中，Keychain提供了安全的存储服务，用来存储一些敏感信息。但是在日常开发中，我们经常会忽视这个苹果自荐的功能，本文的目的就是引起开发者的重视，敏感信息尽量使用Keychain服务。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;NSUserDefaults不安全&quot;&gt;&lt;a href=&quot;#NSUserDefaults不安全&quot; class=&quot;headerlink&quot; title=&quot;NSUserDefaults不安全&quot;&gt;&lt;/a&gt;NSUserDefaults不安全&lt;/h3&gt;&lt;p&gt;NSUserDefaults其实是plist文件中键值存储，并且最大的问题是存在与沙盒中，这就对安全性埋下了隐患。如果攻击者破解app，拿到了沙盒中的数据，就会造成数据泄漏，后果不堪设想。&lt;/p&gt;
&lt;p&gt;当然，一般也不会有把密码直接使用NSUserDefaults存储的，都会进行加密、或者是多重加密后再进行NSUserDefaults存储。这么做其实是可行的，前提是加密算法不能泄漏。有个小问题就是，如果用户删掉app重装的话，之前所有存储的敏感信息都会消失。比如，一个用户误删了使用NSUserDefaults存储密码的app，当重新安装之后，由于以前是记住密码免登录，只因为自己操作不当，接下来要进入找回密码功能，重新修改密码才能再次使用app。这对用户来说是一种相当不友好的体验。&lt;/p&gt;
&lt;p&gt;所以，正确的姿势是使用Keychain服务来存储。Keychain保存的数据不仅仅是加密过的，而且由于Keychain是存在与沙盒之外的，当应用删除之后，app存储的数据并没有被删掉，第二次安装时只要读取Keychain里的数据，即可得到以前存储的信息。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>浅谈iOS事件机制</title>
    <link href="http://yoursite.com/2016/12/10/%E6%B5%85%E8%B0%88iOS%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2016/12/10/浅谈iOS事件机制/</id>
    <published>2016-12-10T08:04:20.000Z</published>
    <updated>2017-07-12T08:05:52.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>在iOS的交互逻辑中，我们做的最多的是事件处理，今天我们就浅谈学习下iOS的事件传递机制。</p>
</blockquote>
<h3 id="iOS中的事件"><a href="#iOS中的事件" class="headerlink" title="iOS中的事件"></a>iOS中的事件</h3><p>在iOS中事件分为3类：</p>
<ul>
<li>Touch Events(触摸事件。包括单击、双击等)；</li>
<li>Motion Events(重力感应、晃动手机等等)；</li>
<li>Remote Events(远程事件，比如耳机音量按键的触发)。</li>
</ul>
<p>不过我们一般接触的Touch Events是最多的，其他两个就不多过介绍了，主要学习下Touch Events。</p>
<h3 id="事件的产生"><a href="#事件的产生" class="headerlink" title="事件的产生"></a>事件的产生</h3><p>在iOS中看到的UIButton可以点击，UIScrollView可以滑动，其实最根本的是UIResponder对象来实现的，只有继承了UIResponder，才能接收并处理事件响应。</p>
<p><code>UIResponder</code>并不是一个视图，是继承<code>NSObject</code>的一个对象。</p>
<a id="more"></a>
<p>我们先看下<code>UIResponder</code>对外暴露的属性和方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">@interface UIResponder : NSObject &lt;UIResponderStandardEditActions&gt;</div><div class="line"></div><div class="line">#if UIKIT_DEFINE_AS_PROPERTIES</div><div class="line">@property(nonatomic, readonly, nullable) UIResponder *nextResponder;</div><div class="line">#else</div><div class="line">- (nullable UIResponder*)nextResponder;</div><div class="line">#endif</div><div class="line"></div><div class="line">#if UIKIT_DEFINE_AS_PROPERTIES</div><div class="line">@property(nonatomic, readonly) BOOL canBecomeFirstResponder;    // default is NO</div><div class="line">#else</div><div class="line">- (BOOL)canBecomeFirstResponder;    // default is NO</div><div class="line">#endif</div><div class="line">- (BOOL)becomeFirstResponder;</div><div class="line"></div><div class="line">#if UIKIT_DEFINE_AS_PROPERTIES</div><div class="line">@property(nonatomic, readonly) BOOL canResignFirstResponder;    // default is YES</div><div class="line">#else</div><div class="line">- (BOOL)canResignFirstResponder;    // default is YES</div><div class="line">#endif</div><div class="line">- (BOOL)resignFirstResponder;</div><div class="line"></div><div class="line">#if UIKIT_DEFINE_AS_PROPERTIES</div><div class="line">@property(nonatomic, readonly) BOOL isFirstResponder;</div><div class="line">#else</div><div class="line">- (BOOL)isFirstResponder;</div><div class="line">#endif</div><div class="line"></div><div class="line">// Generally, all responders which do custom touch handling should override all four of these methods.</div><div class="line">// Your responder will receive either touchesEnded:withEvent: or touchesCancelled:withEvent: for each</div><div class="line">// touch it is handling (those touches it received in touchesBegan:withEvent:).</div><div class="line">// *** You must handle cancelled touches to ensure correct behavior in your application.  Failure to</div><div class="line">// do so is very likely to lead to incorrect behavior or crashes.</div><div class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;</div><div class="line">- (void)touchesMoved:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;</div><div class="line">- (void)touchesEnded:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;</div><div class="line">- (void)touchesCancelled:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;</div><div class="line">- (void)touchesEstimatedPropertiesUpdated:(NSSet&lt;UITouch *&gt; *)touches NS_AVAILABLE_IOS(9_1);</div></pre></td></tr></table></figure>
<p>可以说<code>UIResponder</code>是所有可以响应事件的基类，包括<code>UIView</code>、<code>UIViewController</code>、<code>UIWindow</code>和<code>UIApplication</code>。我们可以看下这些类的定义。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// UIView.h</div><div class="line">NS_CLASS_AVAILABLE_IOS(2_0) @interface UIView : UIResponder</div><div class="line"></div><div class="line">// UIViewController.h</div><div class="line">NS_CLASS_AVAILABLE_IOS(2_0) @interface UIViewController : UIResponder</div><div class="line"></div><div class="line">// UIWindow.h</div><div class="line">NS_CLASS_AVAILABLE_IOS(2_0) @interface UIWindow : UIView</div><div class="line"></div><div class="line">// UIApplication.h</div><div class="line">NS_CLASS_AVAILABLE_IOS(2_0) @interface UIApplication : UIResponder</div></pre></td></tr></table></figure>
<p>可以看到，都继承自<code>UIResponder</code>。可以看出，事件响应的产生来自<code>UIResponder</code>，并且系统会自动调用，除了自定义需求。</p>
<p>比如在自定义的<code>UIView</code>子类中，重写下面的四个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;</div><div class="line">    NSLog(@&quot;UITestView=====touchesBegan触发&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)touchesMoved:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;</div><div class="line">    NSLog(@&quot;UITestView=====touchesMoved触发&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)touchesEnded:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;</div><div class="line">    NSLog(@&quot;UITestView=====touchesEnded触发&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)touchesCancelled:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;</div><div class="line">    // 某个系统事件打断触摸过程，系统会自动调用这个方法，比如电话接入等。</div><div class="line">    NSLog(@&quot;UITestView=====touchesCancelled触发&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>你会发现，当在这个view上做点击、滑动操作时，会触发某些方法的调用。我们可以在这里处理view的触摸事件。比如我们需要实现自定义view可以进行拖拽，那么可以在<code>touchesMoved</code>方法里做：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">- (void)touchesMoved:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;</div><div class="line">    NSLog(@&quot;UITestView=====touchesMoved触发&quot;);</div><div class="line"></div><div class="line">    UITouch *touch = [touches anyObject];</div><div class="line"></div><div class="line">    CGPoint currentPoint = [touch locationInView:self];</div><div class="line">    CGPoint previousPoint = [touch previousLocationInView:self];</div><div class="line"></div><div class="line">    CGFloat offsetX = currentPoint.x - previousPoint.x;</div><div class="line">    CGFloat offsetY = currentPoint.y - previousPoint.y;</div><div class="line"></div><div class="line">    self.transform = CGAffineTransformTranslate(self.transform, offsetX, offsetY);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>好了，我们来总结一下事件响应的产生，从系统底层开始。</p>
<ol>
<li>iOS基于Runloop，其实注册了一个Source1用来接收系统事件；</li>
<li>当手机硬件发生变化，比如触摸、摇晃等，首先通过系统IO来生成一个Event，然后转发给需要的App进程，这时候上面注册的Source1就会触发；</li>
<li>在Source1回调中，会触发Source0，Source0会对Event进行处理，对该Event进行内部分发，并封装成UIEvent，这时候就会调用基本的UIResponder方法；</li>
<li>UIEvent会传递给touchesBegin/Move/End/Cancel，或者<code>UIButton</code>点击等，这些方法会被执行。</li>
</ol>
<h3 id="事件响应传递"><a href="#事件响应传递" class="headerlink" title="事件响应传递"></a>事件响应传递</h3><p>在iOS视图组成中，可以看到其实是一个树状结构，如下图：</p>
<p><img src="https://developer.apple.com/library/content/documentation/General/Conceptual/Devpedia-CocoaApp/Art/view_hierarchy_enclose.jpg" alt="image"></p>
<p>事件响应的传递，其实是参照视图结构，从父控件到子控件这样一个顺序来做的，也就是UIApplication-&gt;UIWindow-&gt;superView-&gt;subView，如果父控件不能接收UIEvent事件，那么其下的子控件肯定不能接收到UIEvent事件。</p>
<p>不过在传递的过程中，如果遇到：</p>
<ol>
<li>该视图不允许交互(userInteractionEnabled = NO);</li>
<li>该视图hidden是YES;</li>
<li>该视图透明度在0~0.01之间。</li>
</ol>
<p>以上三种情况任意一种，该视图都接收不到Touch事件。</p>
<h4 id="如何找到合适的view"><a href="#如何找到合适的view" class="headerlink" title="如何找到合适的view"></a>如何找到合适的view</h4><p>当用户点击屏幕后，系统就会生成一个UIEvent对象，这个事件会放在事件队列中，当处理对象的时候，UIApplication对象会从队列取出UIEvent对象，然后进行分发，以UIApplication-&gt;UIWindow-&gt;superView-&gt;subView的顺序来。具体顺序如下：</p>
<ol>
<li>首先判断主窗口可不可以接收触摸事件，如果可以，判断触摸点在不在自己身上；</li>
<li>遍历自己的子控件，看子控件可不可以接收触摸事件，如果可以，判断触摸点在不在自己身上，然后将触摸事件传递给子控件；</li>
<li>重复上一步操作，判断子控件的子控件可不可以接收触摸事件，如果可以，判断触摸点在不在自己身上，然后将触摸事件传递给子控件；</li>
<li>循环遍历之后，如果最后没有发现合适的子控件，那么其本身就是合适的view。</li>
</ol>
<p>另外，这里涉及到两个两个重要的传递方法，分别是：</p>
<ul>
<li><code>hitTest:withEvent:</code>;</li>
<li><code>pointInside</code>。</li>
</ul>
<p>我们一个一个来说。</p>
<h4 id="hitTest-withEvent"><a href="#hitTest-withEvent" class="headerlink" title="hitTest:withEvent:"></a>hitTest:withEvent:</h4><p><code>hitTest:withEvent:</code>是做事件传递的，下面简称<code>hit-Test</code>。当手指触摸屏幕，发生触摸事件，该UIEvent对象的传递顺序如下所示：</p>
<blockquote>
<p>发生触摸事件 -&gt; 生成UIEvent对象 -&gt; UIWindow hit-Test方法触发 -&gt; superView hit-Test方法触发 -&gt; subView hit-Test方法触发 -&gt; 返回合适的view。</p>
</blockquote>
<p>事件传递给主窗口后，主窗口会将事件往下传递，然后才会在自身查找合适的view。需要注意的是事件传递给window和view后，就会调用hit-Test方法，所以是先将事件传递给子控件，子控件调用hit-Test方法验证自己有没有合适的View，如果父控件是最合适的view，那子控件的hit-Test还是会走的，这里需要注意一下的。</p>
<p>有时候我们需要重写hit-Test，来改变最适合的view，那么请记住修改规则，需要谁成为最合适的view，就重写其父视图的hit-Test方法。</p>
<p>另外，如果去验证问题的话就会发现，每次hit-Test方法会走两次，根据苹果官方的回应，这个是正常的，不用去管。</p>
<h4 id="pointInside"><a href="#pointInside" class="headerlink" title="pointInside"></a>pointInside</h4><p><code>pointInside</code>方法是用来判断触摸点在不在当前view上，如果返回YES，说明在其坐标上；返回NO，说明不在其坐标上。一般和hit-Test方法是成对出现的。</p>
<p>这个方法也比较好理解，需要注意的事，和hit-Test类似，也是会调用两次的。</p>
<p>另外，这两个方法的调用，都是在<code>touchesBegan</code>、<code>touchesMoved</code>、<code>touchesEnded</code>之前发生的，这是因为touch事件的发生，是在已确认合适的view后发生的，所以才会是这样。</p>
<h3 id="事件机制应用"><a href="#事件机制应用" class="headerlink" title="事件机制应用"></a>事件机制应用</h3><p>对于事件机制的应用，网上已经很多，接下来只说下自己经常用到的场景，其实原理都是一样的。</p>
<h4 id="查看当前的触摸点"><a href="#查看当前的触摸点" class="headerlink" title="查看当前的触摸点"></a>查看当前的触摸点</h4><p>在日常开发调试中，有时候需要时时去监听当前点击的坐标值。我们可以重写系统<code>UIApplication</code>的<code>sendEvent</code>方法，来实现此操作。</p>
<p>首先我们继承<code>UIApplication</code>实现一个子类，名为<code>HYApplication</code>，具体代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">@implementation HYApplication</div><div class="line"></div><div class="line">- (void)sendEvent:(UIEvent *)event &#123;</div><div class="line">    [super sendEvent:event];</div><div class="line"></div><div class="line">    if (event.type == UIEventTypeTouches) &#123;</div><div class="line">        if ([[event.allTouches anyObject] phase] == UITouchPhaseBegan) &#123;</div><div class="line">            // 打印出来屏幕触摸坐标</div><div class="line">            CGPoint point = [[event.allTouches anyObject] locationInView:[self mainWindow]];</div><div class="line">            NSLog(@&quot;touching point: %@&quot;, NSStringFromCGPoint(point));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">#pragma mark - Private Methods</div><div class="line">// 获取主窗口</div><div class="line">- (UIWindow *)mainWindow &#123;</div><div class="line">    if ([UIApplication sharedApplication].delegate.window) &#123;</div><div class="line">        return [UIApplication sharedApplication].delegate.window;</div><div class="line">    &#125;else &#123;</div><div class="line">        return [UIApplication sharedApplication].windows[0];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>重写<code>UIApplication</code>的<code>sendEvent</code>方法，进行简单改造，然后修改程序入口main函数，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">#import &lt;UIKit/UIKit.h&gt;</div><div class="line">#import &quot;AppDelegate.h&quot;</div><div class="line">#import &quot;HYApplication.h&quot;</div><div class="line"></div><div class="line">int main(int argc, char * argv[]) &#123;</div><div class="line">    @autoreleasepool &#123;</div><div class="line">        return UIApplicationMain(argc, argv, NSStringFromClass([HYApplication class]), NSStringFromClass([AppDelegate class]));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>把<code>HYApplication</code>添加进去，运行程序，点击任意位置都会打印出坐标了，是不是很方便呢。</p>
<p>其实这里还可以实现其他操作，原理都是一样的。</p>
<h4 id="扩大UIButton的点击区域"><a href="#扩大UIButton的点击区域" class="headerlink" title="扩大UIButton的点击区域"></a>扩大UIButton的点击区域</h4><p>有时候给的设计图上，一个按钮图标会很小，点击区域很小，有时候很别扭。这时候我们就可以重写<code>pointInside</code>方法来实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event &#123;</div><div class="line">    BOOL isInside = CGRectContainsPoint(HitTestingBounds(self.bounds, CGRectGetWidth(self.bounds) + 50, CGRectGetHeight(self.bounds) + 50), point);</div><div class="line">    return isInside;</div><div class="line">&#125;</div><div class="line"></div><div class="line">CGRect HitTestingBounds(CGRect bounds, CGFloat minimumHitTestWidth, CGFloat minimumHitTestHeight) &#123;</div><div class="line">    CGRect hitTestingBounds = bounds;</div><div class="line">    if (minimumHitTestWidth &gt; bounds.size.width) &#123;</div><div class="line">        hitTestingBounds.size.width = minimumHitTestWidth;</div><div class="line">        hitTestingBounds.origin.x -= (hitTestingBounds.size.width - bounds.size.width)/2;</div><div class="line">    &#125;</div><div class="line">    if (minimumHitTestHeight &gt; bounds.size.height) &#123;</div><div class="line">        hitTestingBounds.size.height = minimumHitTestHeight;</div><div class="line">        hitTestingBounds.origin.y -= (hitTestingBounds.size.height - bounds.size.height)/2;</div><div class="line">    &#125;</div><div class="line">    return hitTestingBounds;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样以来，我们把范围扩大到+50的范围，使得点击起来不在那么别扭。</p>
<h4 id="UIResponder分类"><a href="#UIResponder分类" class="headerlink" title="UIResponder分类"></a>UIResponder分类</h4><p>这个最早是在环信的Demo里看到的，个人觉得还是挺好用。是实现了一个<code>UIResponder</code>的category。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">@interface UIResponder (AppResponse)</div><div class="line"></div><div class="line">/**</div><div class="line"> 事件路由，层级传递</div><div class="line"></div><div class="line"> @param eventName 事件名</div><div class="line"> @param userInfo 携带信息</div><div class="line"> */</div><div class="line">-(void)routerEvent:(NSString *)eventName userInfo:(id)userInfo;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation UIResponder (AppResponse)</div><div class="line"></div><div class="line">- (void)routerEvent:(NSString *)eventName userInfo:(id)userInfo &#123;</div><div class="line">    [[self nextResponder] routerEvent:eventName userInfo:userInfo];</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>一个简单的category，对外暴露了一个方法，用来传递事件。正常开发中，我们传递事件一般都是用delegate或者block去做，比如我们需要从view里传递一个事件到controller层，如果有了这个category，可以这么做：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// view层添加一个点击事件，然后事件方法内部调用routerEvent实现事件传递。</div><div class="line">- (void)clickedBtnHandler &#123;</div><div class="line">    [self routerEvent:@&quot;clicked_btn&quot; userInfo:param];</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 然后在controller层监听这个方法，然后在回调里处理相关逻辑。</div><div class="line">- (void)routerEvent:(NSString *)eventName userInfo:(id)userInfo &#123;</div><div class="line">    if ([@&quot;clicked_btn&quot; isEqualStirng:eventName]) &#123;</div><div class="line">        // 拿到获取到的userInfo，来处理点击后的事件。</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样可以使得点击事件和回调有个统一的出发点和着陆点，代码比较好管理，易读。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>关于iOS的事件机制，就说到这里。事件机制代表了我们使用iOS系统的所有操作出发点，也是比较重要的，这块还需要多多理解。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在iOS的交互逻辑中，我们做的最多的是事件处理，今天我们就浅谈学习下iOS的事件传递机制。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;iOS中的事件&quot;&gt;&lt;a href=&quot;#iOS中的事件&quot; class=&quot;headerlink&quot; title=&quot;iOS中的事件&quot;&gt;&lt;/a&gt;iOS中的事件&lt;/h3&gt;&lt;p&gt;在iOS中事件分为3类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Touch Events(触摸事件。包括单击、双击等)；&lt;/li&gt;
&lt;li&gt;Motion Events(重力感应、晃动手机等等)；&lt;/li&gt;
&lt;li&gt;Remote Events(远程事件，比如耳机音量按键的触发)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不过我们一般接触的Touch Events是最多的，其他两个就不多过介绍了，主要学习下Touch Events。&lt;/p&gt;
&lt;h3 id=&quot;事件的产生&quot;&gt;&lt;a href=&quot;#事件的产生&quot; class=&quot;headerlink&quot; title=&quot;事件的产生&quot;&gt;&lt;/a&gt;事件的产生&lt;/h3&gt;&lt;p&gt;在iOS中看到的UIButton可以点击，UIScrollView可以滑动，其实最根本的是UIResponder对象来实现的，只有继承了UIResponder，才能接收并处理事件响应。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;UIResponder&lt;/code&gt;并不是一个视图，是继承&lt;code&gt;NSObject&lt;/code&gt;的一个对象。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>有关Block的一点总结</title>
    <link href="http://yoursite.com/2016/11/16/%E6%9C%89%E5%85%B3Block%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2016/11/16/有关Block的一点总结/</id>
    <published>2016-11-16T02:59:59.000Z</published>
    <updated>2017-07-16T03:02:58.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>Block这种东西，基本上天天都会看到，最近闲下来，总结一下Block的基本知识。</p>
</blockquote>
<h3 id="Block基础用法"><a href="#Block基础用法" class="headerlink" title="Block基础用法"></a>Block基础用法</h3><p>从苹果官方文档来看，Block是一个OC对象，其实可以作为一个可以保存代码块的特殊对象来理解。在合适的时机去执行这块代码。</p>
<p>Block的种类有三种，无参数无返回值的Block、有参数无返回值的Block和有参数和有返回值的Block。</p>
<h4 id="无参数无返回值的Block"><a href="#无参数无返回值的Block" class="headerlink" title="无参数无返回值的Block"></a>无参数无返回值的Block</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">void (^(testBlock))() = ^() &#123;</div><div class="line">    NSLog(@&quot;textBlock&quot;);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">testBlock();</div></pre></td></tr></table></figure>
<h4 id="有参数无返回值的Block"><a href="#有参数无返回值的Block" class="headerlink" title="有参数无返回值的Block"></a>有参数无返回值的Block</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">void (^(appendString))(NSString *str1, NSString *str2) = ^(NSString *str1, NSString *str2) &#123;</div><div class="line">    NSString *appendStr = [NSString stringWithFormat:@&quot;%@%@&quot;, str1, str2];</div><div class="line">    NSLog(@&quot;%@&quot;, appendStr);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">appendString(@&quot;123&quot;, @&quot;456&quot;);</div></pre></td></tr></table></figure>
<h4 id="有参数有返回值的Block"><a href="#有参数有返回值的Block" class="headerlink" title="有参数有返回值的Block"></a>有参数有返回值的Block</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">NSString* (^(appendString))(NSString *str1, NSString *str2) = ^(NSString *str1, NSString *str2) &#123;</div><div class="line">    NSString *appendStr = [NSString stringWithFormat:@&quot;%@%@&quot;, str1, str2];</div><div class="line">    return appendStr;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">NSLog(@&quot;%@&quot;, appendString(@&quot;123&quot;, @&quot;456&quot;));</div></pre></td></tr></table></figure>
<p>这些事Block的基本用法，不过并不是这篇文章的关键，在总结Block的关键知识点之前，我们先来回顾一下iOS的内存分配机制。</p>
<a id="more"></a>
<h3 id="iOS内存分配"><a href="#iOS内存分配" class="headerlink" title="iOS内存分配"></a>iOS内存分配</h3><p>在开始之前，先来讲讲iOS程序中内存分配的知识。搬张图来看看内存区域的划分。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1232160-0db68b7366e194e3.png?imageMogr2/auto-orient/strip%7CimageView2/2" alt="内存分配"></p>
<h4 id="栈区"><a href="#栈区" class="headerlink" title="栈区"></a>栈区</h4><p>栈是向低地址扩展的数据结构，是一块连续的内存区域。其栈顶和栈的最大容量是系统事先规定好的，如果申请空间超过栈的剩余空间，就会提示栈溢出，一般栈空间是很小的，用来存放函数的参数值，局部变量等等。</p>
<h4 id="堆区"><a href="#堆区" class="headerlink" title="堆区"></a>堆区</h4><p>堆和栈相反，是向高地址扩展的数据结构，并且不是一块连续的内存区域。对于堆内存来讲，系统会有一张链表用来记录空闲内存地址的，当系统收到堆内存申请时，会遍历该链表，找到第一个空闲内存大于申请空间的堆结点地址，将空间分配给使用者。和栈相比，堆的大小只受限于操作系统的虚拟内存大小，目前来说已经足够大，所以空间充足。</p>
<p>堆内存的分配和释放是由开发者去控制的，在iOS中，一般我们创建一个对象，就是存放在堆中的，其分配内存是用alloc方法实现，其内存释放就是使用release方法来进行内存释放。</p>
<h4 id="全局区"><a href="#全局区" class="headerlink" title="全局区"></a>全局区</h4><p>全局区有时候也叫静态区，是用来存储全局变量和静态变量的。全局区包括两块区域，一块是存放未初始化过全局变量和静态变量的，另一块是存放已经初始化过的全局变量和静态变量。</p>
<p>在一些其他文章中，全局区属于数据区的范畴，下面讲到的常量区也属于数据区范畴。</p>
<h4 id="常量区"><a href="#常量区" class="headerlink" title="常量区"></a>常量区</h4><p>常量区顾名思义，存放一些程序是用到的常量，程序结束后由系统释放。</p>
<h4 id="代码区"><a href="#代码区" class="headerlink" title="代码区"></a>代码区</h4><p>代码区是存放程序运行的二进制代码的。</p>
<p>一般app启动之后，全局区、常量区和代码区都已经固定，分配完毕。变化的是堆区和栈区的内存分配。当内存已经释放，但是还有指针指向这块，这时会造成野指针。</p>
<p>盗用一位前辈总结的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">//main.cpp</div><div class="line">int a = 0; // 全局初始化区</div><div class="line">char *p1; // 全局未初始化区</div><div class="line">main &#123;</div><div class="line">    int b; // 栈</div><div class="line">    char s[] = &quot;abc&quot;; // 栈</div><div class="line">    char *p2; // 栈</div><div class="line">    char *p3 = &quot;123456&quot;; // 123456\0在常量区，p3在栈上</div><div class="line">    static int c =0； // 全局静态初始化区</div><div class="line">    p1 = (char *)malloc(10);</div><div class="line">    p2 = (char *)malloc(20); // 分配得来的10和20字节的区域就在堆区</div><div class="line">    strcpy(p1, &quot;123456&quot;); // 123456\0在常量区，这个函数的作用是将&quot;123456&quot; 这串字符串复制一份放在p1申请的10个字节的堆区域中。</div><div class="line">    // p3指向的&quot;123456&quot;与这里的&quot;123456&quot;可能会被编译器优化成一个地址。</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Block知识点总结"><a href="#Block知识点总结" class="headerlink" title="Block知识点总结"></a>Block知识点总结</h3><h4 id="Block捕获外部变量"><a href="#Block捕获外部变量" class="headerlink" title="Block捕获外部变量"></a>Block捕获外部变量</h4><p>首先，Block捕获外部变量仅仅只会捕获闭包里用到的值，没有用到的并不会去捕获。</p>
<p>如果外部变量是全局变量或者是静态全局变量，Block捕获之后，由于是全局的，在闭包结束之后，其改变的值仍然可以保存下来，所以如果Block捕获外部变量是全局的，在Block回调内部修改了该变量，可以直接修改，不用加<code>__block</code>。</p>
<p>如果外部变量是静态变量，那么修改也是不需要<code>__block</code>的，因为静态变量传递给Block的是内存地址，所以Block也可以直接修改该值。</p>
<p>但是，如果外部变量是自动变量的话，是不能直接修改的，是因为Block捕获到的是自动变量的值，并非内存地址。如果需要修改，那么只有加上<code>__block</code>才会生效。</p>
<p>所以，可以总结一下，在Block中有两种可以修改值的方式，一是传递内存地址到Block中，二是使用<code>__blcok</code>修饰。</p>
<h4 id="Block常见类型"><a href="#Block常见类型" class="headerlink" title="Block常见类型"></a>Block常见类型</h4><p><strong>_NSConcreteStackBlock</strong></p>
<p>这是保存在栈中的block，当函数返回时该block会销毁。这种block的特点是只会执行一次就出栈了，可以访问外部变量。</p>
<p><strong>_NSConcreteMallocBlock</strong></p>
<p>这是保存在堆中的block，当引用计数为0时会被销毁。该类型的block都是由<code>_NSConcreteStackBlock</code>类型的block从栈中复制到堆中形成的。</p>
<p>该类型的block可以执行多次，当需要执行多次时，会把block从栈上复制到堆上，提供多次使用。</p>
<p><strong>_NSConcreteGlobalBlock</strong></p>
<p>这是全局Block，不会访问任何外部变量，不会涉及到任何拷贝。要么是一个空block，它既不在堆中，也不再栈中。</p>
<h4 id="copy-和dispose"><a href="#copy-和dispose" class="headerlink" title="copy()和dispose()"></a>copy()和dispose()</h4><p>上面说过，如果需要多次使用该block，那么需要将block拷贝到堆上，提供多次使用。这个拷贝操作其实就是调用<code>Block_copy()</code>函数来实现。</p>
<p>有拷贝就会有释放，<code>Block_copy()</code>对应的是<code>Block_release()</code>，其对应的辅助函数就是<code>copy()</code>和<code>dispose()</code>。</p>
<h4 id="block中的weakSelf和strongSelf"><a href="#block中的weakSelf和strongSelf" class="headerlink" title="block中的weakSelf和strongSelf"></a>block中的weakSelf和strongSelf</h4><p>需要使用weakSelf，是因为防止循环引用，一般使用block的场景中，self会对block强引用，在block内部回调中，block又强引用了self，所以造成循环引用，使用weakSelf，可以打破这一闭环，使得block内部回调中不会对self发生强引用，就解决了问题。</p>
<p>使用strongSelf，是因为外部使用了weakSelf，在Block内部回调中，这个weakSelf可能会被释放，造成接下来的操作无法完成，如果是KVO操作，还是引发崩溃。所以在Block内部需要使用strongSelf，防止weakSelf提前释放。需要注意的是，这个strongSelf的作用域在block内部回调，出了这个回调就会失效，所以这么写既能正常释放，又不会崩溃。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Block这种东西，基本上天天都会看到，最近闲下来，总结一下Block的基本知识。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;Block基础用法&quot;&gt;&lt;a href=&quot;#Block基础用法&quot; class=&quot;headerlink&quot; title=&quot;Block基础用法&quot;&gt;&lt;/a&gt;Block基础用法&lt;/h3&gt;&lt;p&gt;从苹果官方文档来看，Block是一个OC对象，其实可以作为一个可以保存代码块的特殊对象来理解。在合适的时机去执行这块代码。&lt;/p&gt;
&lt;p&gt;Block的种类有三种，无参数无返回值的Block、有参数无返回值的Block和有参数和有返回值的Block。&lt;/p&gt;
&lt;h4 id=&quot;无参数无返回值的Block&quot;&gt;&lt;a href=&quot;#无参数无返回值的Block&quot; class=&quot;headerlink&quot; title=&quot;无参数无返回值的Block&quot;&gt;&lt;/a&gt;无参数无返回值的Block&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;void (^(testBlock))() = ^() &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    NSLog(@&amp;quot;textBlock&amp;quot;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;testBlock();&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;有参数无返回值的Block&quot;&gt;&lt;a href=&quot;#有参数无返回值的Block&quot; class=&quot;headerlink&quot; title=&quot;有参数无返回值的Block&quot;&gt;&lt;/a&gt;有参数无返回值的Block&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;void (^(appendString))(NSString *str1, NSString *str2) = ^(NSString *str1, NSString *str2) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    NSString *appendStr = [NSString stringWithFormat:@&amp;quot;%@%@&amp;quot;, str1, str2];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    NSLog(@&amp;quot;%@&amp;quot;, appendStr);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;appendString(@&amp;quot;123&amp;quot;, @&amp;quot;456&amp;quot;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;有参数有返回值的Block&quot;&gt;&lt;a href=&quot;#有参数有返回值的Block&quot; class=&quot;headerlink&quot; title=&quot;有参数有返回值的Block&quot;&gt;&lt;/a&gt;有参数有返回值的Block&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;NSString* (^(appendString))(NSString *str1, NSString *str2) = ^(NSString *str1, NSString *str2) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    NSString *appendStr = [NSString stringWithFormat:@&amp;quot;%@%@&amp;quot;, str1, str2];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    return appendStr;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;NSLog(@&amp;quot;%@&amp;quot;, appendString(@&amp;quot;123&amp;quot;, @&amp;quot;456&amp;quot;));&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这些事Block的基本用法，不过并不是这篇文章的关键，在总结Block的关键知识点之前，我们先来回顾一下iOS的内存分配机制。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>load和initialize的特殊之处</title>
    <link href="http://yoursite.com/2016/10/03/load%E5%92%8Cinitialize%E7%9A%84%E7%89%B9%E6%AE%8A%E4%B9%8B%E5%A4%84/"/>
    <id>http://yoursite.com/2016/10/03/load和initialize的特殊之处/</id>
    <published>2016-10-03T03:56:22.000Z</published>
    <updated>2017-07-16T03:57:30.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>在NSObject.h中提供了两个特殊的类方法，load和initialize。帮助我们进行类的加载和初始化。</p>
</blockquote>
<p>既然是进行类的加载和初始化的，那么它们的调用时机是什么，又有什么区别呢？我们一起来看下。</p>
<h3 id="load"><a href="#load" class="headerlink" title="+load"></a>+load</h3><p>我们先做以下实验：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">// Son.h (继承Father类)</div><div class="line">+ (void)load &#123;</div><div class="line">    NSLog(@&quot;Son is loaded&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Father.h</div><div class="line">+ (void)load &#123;</div><div class="line">    NSLog(@&quot;Father is loaded&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Son+Load.h</div><div class="line">+ (void)load &#123;</div><div class="line">    NSLog(@&quot;Son+Load is loaded&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到打印结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">iOSTest[1120:83646] Father is loaded</div><div class="line">iOSTest[1120:83646] Son is loaded</div><div class="line">iOSTest[1120:83646] Son+Load is loaded</div></pre></td></tr></table></figure>
<p>说明，一个类如果实现了<code>load</code>方法，那么调用该方法之前，会先找父类的<code>load</code>方法，然后在调用自己的<code>load</code>方法。</p>
<p>如果是这个类的<code>category</code>的话，那么会先调用自己的<code>load</code>方法，然后再调用<code>category</code>的<code>load</code>方法。</p>
<a id="more"></a>
<p>需要注意的事，<code>load</code>方法的本质是直接执行函数指针的，因此不像普通方法调用，会走<code>objc_msgSend</code>这套流程，<code>load</code>方法并不会走<code>objc_msgSend</code>这套流程，有兴趣的同学可以看下源码，这里就不讨论那么多了。</p>
<p>另外就是有关执行顺序的问题，<code>load</code>方法执行，先是父类方法执行，然后是子类，最后是<code>category</code>中的方法执行。如果是不相关的两个类中<code>load</code>方法的执行顺序，和<code>Build Phases</code>中的<code>Compile Sources</code>文件顺序有关，放在前面的先执行。</p>
<p>还有一点很关键，<code>load</code>方法只会被调用一次，<code>initialize</code>也是的。</p>
<p>对于<code>load</code>方法的实践，大多是基于它开发中调用时间最早的特性。目前用的最多的就是Method Swizzling。比如经常用的Controller方法替换。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">#import &lt;objc/runtime.h&gt;</div><div class="line"></div><div class="line">@implementation UIViewController (Tracking)</div><div class="line"></div><div class="line">+ (void)load &#123;</div><div class="line">    static dispatch_once_t onceToken;</div><div class="line">    dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">        Class class = [self class];</div><div class="line"></div><div class="line">        SEL originalSelector = @selector(viewWillAppear:);</div><div class="line">        SEL swizzledSelector = @selector(xxx_viewWillAppear:);</div><div class="line"></div><div class="line">        Method originalMethod = class_getInstanceMethod(class, originalSelector);</div><div class="line">        Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector);</div><div class="line"></div><div class="line">        // When swizzling a class method, use the following:</div><div class="line">        // Class class = object_getClass((id)self);</div><div class="line">        // ...</div><div class="line">        // Method originalMethod = class_getClassMethod(class, originalSelector);</div><div class="line">        // Method swizzledMethod = class_getClassMethod(class, swizzledSelector);</div><div class="line"></div><div class="line">        BOOL didAddMethod =</div><div class="line">            class_addMethod(class,</div><div class="line">                originalSelector,</div><div class="line">                method_getImplementation(swizzledMethod),</div><div class="line">                method_getTypeEncoding(swizzledMethod));</div><div class="line"></div><div class="line">        if (didAddMethod) &#123;</div><div class="line">            class_replaceMethod(class,</div><div class="line">                swizzledSelector,</div><div class="line">                method_getImplementation(originalMethod),</div><div class="line">                method_getTypeEncoding(originalMethod));</div><div class="line">        &#125; else &#123;</div><div class="line">            method_exchangeImplementations(originalMethod, swizzledMethod);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">#pragma mark - Method Swizzling</div><div class="line"></div><div class="line">- (void)xxx_viewWillAppear:(BOOL)animated &#123;</div><div class="line">    [self xxx_viewWillAppear:animated];</div><div class="line">    NSLog(@&quot;viewWillAppear: %@&quot;, self);</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>不过，除了Method Swizzling，其他的东西还是少放，调用<code>load</code>方法的时候环境并不安全，也不要放线程堵塞的代码上去。</p>
<h3 id="initialize"><a href="#initialize" class="headerlink" title="initialize"></a>initialize</h3><p>一样，我们先做个实验：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">// Son.h (继承Father类)</div><div class="line">+ (void)initialize &#123;</div><div class="line">    NSLog(@&quot;Son is initialized&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Father.h</div><div class="line">+ (void)initialize &#123;</div><div class="line">    NSLog(@&quot;Father is initialized&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Son+Initialize.h</div><div class="line">+ (void)initialize &#123;</div><div class="line">    NSLog(@&quot;Son+Load is initialized&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们什么先都不做，运行可以发现，什么都没打印。于<code>load</code>不同，<code>initialize</code>是惰性的，只会在第一次调用类的方法时去调用。</p>
<p>然后我们在修改一下上面的代码，去掉category那块，然后在主函数里创建一个Father对象，查看打印：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// Son.h (继承Father类)</div><div class="line">+ (void)initialize &#123;</div><div class="line">    NSLog(@&quot;Son is initialized&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Father.h</div><div class="line">+ (void)initialize &#123;</div><div class="line">    NSLog(@&quot;Father is initialized&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// main.h</div><div class="line">Father *father = [[Father alloc] init];</div></pre></td></tr></table></figure>
<p>运行可以发现，控制台打印出了一条，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Father is initialized</div></pre></td></tr></table></figure>
<p>然后，我们修改主函数，创建一个Son对象，运行之后发现，打印了两条：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Father is initialized</div><div class="line">Son is initialized</div></pre></td></tr></table></figure>
<p>可以看到，创建子类对象会调用父类的<code>initialize</code>方法，并且是先执行父类的，然后执行子类的。那么我们可以得出，<code>initialize</code>方法的执行顺序是先执行父类的，然后执行子类的。</p>
<p>接下来我们还原代码，添加上catagory那块，在main函数里创建一个Son对象，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">// Son.h (继承Father类)</div><div class="line">+ (void)initialize &#123;</div><div class="line">    NSLog(@&quot;Son is initialized&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Father.h</div><div class="line">+ (void)initialize &#123;</div><div class="line">    NSLog(@&quot;Father is initialized&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Son+Initialize.h</div><div class="line">+ (void)initialize &#123;</div><div class="line">    NSLog(@&quot;Son+Initialize is initialized&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// main.h</div><div class="line">Son *son = [[Son alloc] init];</div></pre></td></tr></table></figure>
<p>运行后，发现，控制台仍然只打印了两条日志，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Father is initialized</div><div class="line">Son+Initialize is initialized</div></pre></td></tr></table></figure>
<p>关键点来了，我们发现，和<code>load</code>方法不一样，并没有打印三条日志，并且没有打印出Son子类的<code>initialize</code>方法。这是比较关键的，是因为<code>initialize</code>方法只会在第一次调用当前类的时候被调用，并且只会调用一次。既然走了Son的category的方法，那么就并不会走其本身的<code>initialize</code>方法了。</p>
<p>接下来我们继续修改代码，在主函数里多创建几个Son对象，发现日志没有变化，仍旧只是两条打印：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Father is initialized</div><div class="line">Son+Initialize is initialized</div></pre></td></tr></table></figure>
<p>这说明<code>initialize</code>方法只会走一次，这块和<code>load</code>方法还是有点像的。</p>
<p>一般<code>initialize</code>的使用场景比较少，如果需要在类调用前需要定义一些常量，可以在这里做。并且<code>initialize</code>方法内部也是线程安全的，这个也很关键。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在NSObject.h中提供了两个特殊的类方法，load和initialize。帮助我们进行类的加载和初始化。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;既然是进行类的加载和初始化的，那么它们的调用时机是什么，又有什么区别呢？我们一起来看下。&lt;/p&gt;
&lt;h3 id=&quot;load&quot;&gt;&lt;a href=&quot;#load&quot; class=&quot;headerlink&quot; title=&quot;+load&quot;&gt;&lt;/a&gt;+load&lt;/h3&gt;&lt;p&gt;我们先做以下实验：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;// Son.h (继承Father类)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;+ (void)load &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    NSLog(@&amp;quot;Son is loaded&amp;quot;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;// Father.h&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;+ (void)load &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    NSLog(@&amp;quot;Father is loaded&amp;quot;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;// Son+Load.h&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;+ (void)load &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    NSLog(@&amp;quot;Son+Load is loaded&amp;quot;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;可以看到打印结果如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;iOSTest[1120:83646] Father is loaded&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;iOSTest[1120:83646] Son is loaded&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;iOSTest[1120:83646] Son+Load is loaded&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;说明，一个类如果实现了&lt;code&gt;load&lt;/code&gt;方法，那么调用该方法之前，会先找父类的&lt;code&gt;load&lt;/code&gt;方法，然后在调用自己的&lt;code&gt;load&lt;/code&gt;方法。&lt;/p&gt;
&lt;p&gt;如果是这个类的&lt;code&gt;category&lt;/code&gt;的话，那么会先调用自己的&lt;code&gt;load&lt;/code&gt;方法，然后再调用&lt;code&gt;category&lt;/code&gt;的&lt;code&gt;load&lt;/code&gt;方法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Swift学习之闭包</title>
    <link href="http://yoursite.com/2016/04/21/Swift%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%97%AD%E5%8C%85/"/>
    <id>http://yoursite.com/2016/04/21/Swift学习之闭包/</id>
    <published>2016-04-21T02:03:15.000Z</published>
    <updated>2017-07-12T08:51:13.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>作为一门现代编程语言，Swift对函数式编程范式有着良好的支持，而函数式编程又和闭包有着紧密的关系，今天我们就学习下闭包这个概念。</p>
</blockquote>
<p>闭包的出现，可能会打破脑海中存在已久的函数概念，</p>
<p>一般来说，一个函数只会有一个实例，而闭包的出现，使得函数可以有多个实例。当然，函数得处于其相关的上下文环境中。闭包这个概念，在OC/C中叫做Blocks，用过的人都知道，好难理解Blocks这东西到底是干嘛的，十分晦涩。原因在于，不管是OC或者是Java，都是一门面向对象语言，由于面向对象语言本身对函数具有局限性，闭包的实现，是迫于编程语言的发展趋势而添加的特性，光看代码，就感觉好像一个补丁。  </p>
<p>在说闭包之前，需要先谈谈“自由变量”这个概念，那么什么是自由变量呢？</p>
<blockquote>
<p>本意应该是在一个作用域中，如果使用未在本作用域中声明的变量，那么对于此作用域，该变量就是一个自由变量。</p>
</blockquote>
<p>而闭包，就是一个引用了自由变量的函数，自由变量将和函数一同存在。  </p>
<p>在谈谈“高阶函数”，什么是高阶函数？</p>
<blockquote>
<p>高阶函数就是接受一个或者多个函数当作参数，并且返回值也是个函数的函数。</p>
</blockquote>
<p>在命令式的编程语言中，对函数的看法往往比较局限，认为函数就是一系列语句的集合。而在函数式编程语言中，函数是十分灵活的，这就使得在Swift中闭包变得十分简单，在Swift中，函数都是高阶函数，而高阶函数需要函数先成为闭包，下面给个简单的高阶函数的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">func makeCounter() -&gt; (() -&gt; Int) &#123;</div><div class="line">    var count = 0</div><div class="line"></div><div class="line">    func add() -&gt; Int &#123;</div><div class="line">        count += 1</div><div class="line">        return count</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return add</div><div class="line">&#125;</div><div class="line"></div><div class="line">let add = makeCounter()</div><div class="line">add()		//1</div><div class="line">add()		//2</div></pre></td></tr></table></figure>
<p>例子是实现一个自增的高阶函数，我们可以看出，<code>makeCounter</code>返回的并不是一个数据值，而是一个函数。当我们在全局中获取到<code>makeCounter</code>的返回函数后，每执行一次，都会进行加一操作，说明虽然我们离开了<code>count</code>的作用域，但还是可以使用<code>count</code>的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let add2 = makeCounter()</div><div class="line">add2()		//1</div><div class="line">add2()		//2</div></pre></td></tr></table></figure>
<p>我们再来获取一个函数返回值，会发现，输出结果依然是1、2。这说明，此函数可以有多个实例，它们有着自己的count值，之间并不共享。  </p>
<a id="more"></a>
<p>但是，对象和闭包还是有区别的。对象是一种数据，它有着属性和行为，而闭包，可以称它是一种行为，和对象的行为所不同的是，它是附有数据的，它可以获取到自由变量。在函数式编程中，如果函数是闭包的，那么它就有了和对象同等的地位，一般来说，通常把这种地位叫做“一等函数”。  </p>
<p>以前了解过Blocks的话，会时不时听到匿名函数这个概念。那什么是匿名函数呢？就拿上面的例子来说，细心的会不会发现，<code>makeCounter</code>里面的<code>add</code>这个内部函数除了被返回，并没有什么卵用。其实根本就不需要名字，可以被定义成一个匿名函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">func makeCounter2() -&gt; (() -&gt; Int) &#123;</div><div class="line">    var count = 0</div><div class="line">    return&#123;() -&gt; Int in</div><div class="line">        count += 1</div><div class="line">        return count</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>使用闭包，可以使编程模块化，我们可以将一些小的模块使用闭包完成，提高开发速度和程序的复用性。另外，使用闭包可以简化代码，用过GCD＋Blocks的人应该都理解，闭包可以让处理问题变的比较方便，代码量也会少很多，用好了受益无穷！  </p>
<blockquote>
<p>总之一句话，代码写的更优雅了  ^()^</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作为一门现代编程语言，Swift对函数式编程范式有着良好的支持，而函数式编程又和闭包有着紧密的关系，今天我们就学习下闭包这个概念。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;闭包的出现，可能会打破脑海中存在已久的函数概念，&lt;/p&gt;
&lt;p&gt;一般来说，一个函数只会有一个实例，而闭包的出现，使得函数可以有多个实例。当然，函数得处于其相关的上下文环境中。闭包这个概念，在OC/C中叫做Blocks，用过的人都知道，好难理解Blocks这东西到底是干嘛的，十分晦涩。原因在于，不管是OC或者是Java，都是一门面向对象语言，由于面向对象语言本身对函数具有局限性，闭包的实现，是迫于编程语言的发展趋势而添加的特性，光看代码，就感觉好像一个补丁。  &lt;/p&gt;
&lt;p&gt;在说闭包之前，需要先谈谈“自由变量”这个概念，那么什么是自由变量呢？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本意应该是在一个作用域中，如果使用未在本作用域中声明的变量，那么对于此作用域，该变量就是一个自由变量。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;而闭包，就是一个引用了自由变量的函数，自由变量将和函数一同存在。  &lt;/p&gt;
&lt;p&gt;在谈谈“高阶函数”，什么是高阶函数？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;高阶函数就是接受一个或者多个函数当作参数，并且返回值也是个函数的函数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在命令式的编程语言中，对函数的看法往往比较局限，认为函数就是一系列语句的集合。而在函数式编程语言中，函数是十分灵活的，这就使得在Swift中闭包变得十分简单，在Swift中，函数都是高阶函数，而高阶函数需要函数先成为闭包，下面给个简单的高阶函数的例子：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;func makeCounter() -&amp;gt; (() -&amp;gt; Int) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    var count = 0&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    func add() -&amp;gt; Int &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        count += 1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        return count&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    return add&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;let add = makeCounter()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;add()		//1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;add()		//2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;例子是实现一个自增的高阶函数，我们可以看出，&lt;code&gt;makeCounter&lt;/code&gt;返回的并不是一个数据值，而是一个函数。当我们在全局中获取到&lt;code&gt;makeCounter&lt;/code&gt;的返回函数后，每执行一次，都会进行加一操作，说明虽然我们离开了&lt;code&gt;count&lt;/code&gt;的作用域，但还是可以使用&lt;code&gt;count&lt;/code&gt;的值。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;let add2 = makeCounter()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;add2()		//1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;add2()		//2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;我们再来获取一个函数返回值，会发现，输出结果依然是1、2。这说明，此函数可以有多个实例，它们有着自己的count值，之间并不共享。  &lt;/p&gt;
    
    </summary>
    
    
      <category term="Swift" scheme="http://yoursite.com/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift之自动引用计数</title>
    <link href="http://yoursite.com/2016/04/05/Swift%E4%B9%8B%E8%87%AA%E5%8A%A8%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/"/>
    <id>http://yoursite.com/2016/04/05/Swift之自动引用计数/</id>
    <published>2016-04-05T08:04:27.000Z</published>
    <updated>2017-07-12T08:49:31.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>这个概念并不是Swift专有，在Objective-C中就已经运用广泛。运用这种机制，能很好地跟踪和管理应用程序的内存。  </p>
</blockquote>
<p>在早期，Apple一直使用的是MRC，这篇文章并不想讲解MRC，使用MRC时，Swift还没有诞生呢。MRC是手动管理内存的，比如创建一个实例对象，如果需要释放该对象，是需要手动去释放的。而使用ARC的好处是，ARC可以自动的帮您管理内存，自动释放其占有的内存。  </p>
<p>特别注意：不管是ARC还是MRC，引用计数只仅仅应用于类的实例，不能应用于结构体和枚举类型。  </p>
<h3 id="自动引用计数原理"><a href="#自动引用计数原理" class="headerlink" title="自动引用计数原理"></a>自动引用计数原理</h3><p>首先记住，每创建一个新的实例，ARC会自动分配给一块内存用来存储实例的信息，当内存不再使用时，ARC会释放实例所占的内存，供其他实例使用。  </p>
<p>为了分辨实例是否正在处于使用的情况，ARC会跟踪和计算每一个实例的引用次数，如果实例的引用次数小于1，那么ARC会销毁这个实例。  </p>
<p>下面给出一个例子，用来解释ARC的运行机制，我们先实现一个Person类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class Person &#123;</div><div class="line">    let name: String</div><div class="line"></div><div class="line">    init(name: String) &#123;</div><div class="line">        self.name = name</div><div class="line">        print(&quot;\(name)正在被初始化&quot;)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    deinit &#123;</div><div class="line">        print(&quot;\(name)正在被销毁&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Person类很简单，有一个名为name的属性，然后重写<code>init</code>和<code>deinit</code>方法。然后我们定义三个变量来对Person类进行引用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var person1: Person?</div><div class="line">var person2: Person?</div><div class="line">var person3: Person?</div></pre></td></tr></table></figure>
<p>可选选项可以保证在没实例化之前是nil。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">person1 = Person(name: &quot;Jack&quot;)</div><div class="line">person2 = person1</div><div class="line">person3 = person1</div></pre></td></tr></table></figure>
<p>当我们对person1执行实例化时，会打印出<code>Jack正在被初始化</code>，说明Person实例赋值给了person1，需要注意的是，两者之间是建立了一个强引用，强引用可以保证Person实例可以保持在内存中不被销毁。将同一个实例也赋值给person2和person3，又回多出两个强引用，所以现在Person实例有三个强引用。  </p>
<p>接下来我们通过赋值<code>nil</code>来断开强引用关系。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">person1 = nil</div><div class="line">person2 = nil</div></pre></td></tr></table></figure>
<p>然后我们断开person3的强引用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">person3 = nil</div></pre></td></tr></table></figure>
<p>这时我们发现，Console中打印出了<code>Jack正在被销毁</code>的log。所以说明，当一个实例不再有强引用关系时，ARC会自动销毁存在在内存中的该实例，释放内存供其他实例使用。</p>
<a id="more"></a>
<h3 id="循环引用问题"><a href="#循环引用问题" class="headerlink" title="循环引用问题"></a>循环引用问题</h3><p>这个问题发生的原因很简单，就是使用ARC的话，我们会发现有时候引用计数永远也不会为0，两个类之间互相持有对方的强引用，这就是所谓的循环强引用问题。  </p>
<p>我们先来看看强引用是怎么产生的，首先定义两个类，Person和Apartment，代表人和公寓两个对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">class Person &#123;</div><div class="line">    let name: String</div><div class="line">    var apartment: Apartment?</div><div class="line"></div><div class="line">    init(name: String) &#123;</div><div class="line">        self.name = name</div><div class="line">        print(&quot;\(name)正在被初始化&quot;)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    deinit &#123;</div><div class="line">        print(&quot;\(name)正在被销毁&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Apartment &#123;</div><div class="line">    let unit: String</div><div class="line">    var person: Person?</div><div class="line"></div><div class="line">    init (unit: String) &#123;</div><div class="line">        self.unit = unit</div><div class="line">        print(&quot;\(unit)正在被初始化&quot;)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    deinit &#123;</div><div class="line">        print(&quot;\(unit)正在被销毁&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>之所以要将变量定义成可选的，是因为不是每个人都有公寓的，类似的，不是每个公寓都有人住，所以符合现实需求。  </p>
<p>然后我们定义两个变量，分别对Person和Apartment的引用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var per: Person?</div><div class="line">var apart: Apartment?</div><div class="line"></div><div class="line">per = Person(name: &quot;Jack&quot;)</div><div class="line">apart = Apartment(unit: &quot;4A&quot;)</div></pre></td></tr></table></figure>
<p>注意，对于对象的引用为强引用。但是如何实现人住进公寓，公寓里有人呢，来看看实现方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">per!.apartment = apart</div><div class="line">apart!.person = per</div></pre></td></tr></table></figure>
<p>现在，实现了上面所说的功能，但是不幸的是，这里会造成一个循环引用，Person实例有一个指向Apartment实例的引用，而Apartment实例有一个指向Person实例的引用。这时，像上面的处理一样，我们把变量设为<code>nil</code>。看会不会销毁。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">per = nil</div><div class="line">apart = nil</div></pre></td></tr></table></figure>
<p>我们发现，并没有打印销毁log，说明Person和Apartment实例之间的强引用保留了下来并不会断开。这就是我们常说的循环引用。</p>
<h3 id="循环引用解决办法"><a href="#循环引用解决办法" class="headerlink" title="循环引用解决办法"></a>循环引用解决办法</h3><p>以前在Objective-C中，如果出现了循环引用，那么使用<code>weak</code>可以解决问题，那在Swift中一样，只不过在Swift中有两种解决办法，一种是weak，另外一种是unowned。  </p>
<p>两者的解决办法都相似，就是允许一个实例引用另外一个实例但不保持强引用。  </p>
<h4 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h4><p>和强引用对比，弱引用不会对其引用的实例保持强引用，这一特性阻止了变成循环强引用的端倪。  </p>
<p>弱引用必须被声明为变量，而且可以没有值，我们还是依照上面的那个例子，但是这次Apartment类有些改动：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">class Apartment &#123;</div><div class="line">    let unit: String</div><div class="line">    weak var person: Person?</div><div class="line"></div><div class="line">    init (unit: String) &#123;</div><div class="line">        self.unit = unit</div><div class="line">        print(&quot;\(unit)正在被初始化&quot;)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    deinit &#123;</div><div class="line">        print(&quot;\(unit)正在被销毁&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们将person设为weak类型，然后将变量指向nil。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">per = nil</div><div class="line">apart = nil</div></pre></td></tr></table></figure>
<p>我们会发现，这次执行了销毁方法，打印出了log，说明循环引用被我们打破了。  </p>
<h4 id="无主引用"><a href="#无主引用" class="headerlink" title="无主引用"></a>无主引用</h4><p>和弱引用不同的是，弱引用是没有值时也可以用，无主引用时要保证总是有值。因此，无主引用一般总是被定义为非可选类型。判断到底是用弱引用还是无主引用，只要根据该引用是可选类型的还是非可选类型的。</p>
<h3 id="闭包引起的循环引用"><a href="#闭包引起的循环引用" class="headerlink" title="闭包引起的循环引用"></a>闭包引起的循环引用</h3><p>在真实的开发中，很多循环引用都发生在此，那么为什么会发生呢？我们以一个例子作为参考，先实现一个简单的HTML类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">class HTMLElement &#123;</div><div class="line"></div><div class="line">    let name: String</div><div class="line">    let text: String?</div><div class="line"></div><div class="line">    lazy var asHTML: Void -&gt; String = &#123;</div><div class="line">        if let text = self.text &#123;</div><div class="line">            return &quot;&lt;\(self.name)&gt;\(text)&lt;/\(self.name)&gt;&quot;</div><div class="line">        &#125;else &#123;</div><div class="line">            return &quot;&lt;\(self.name) /&gt;&quot;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    init(name: String, text: String? = nil) &#123;</div><div class="line">        self.name = name</div><div class="line">        self.text = text</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    deinit &#123;</div><div class="line">        print(&quot;HTMLElement对象被销毁&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>很简单，类中包括一个闭包，是根据属性值来返回不同的数据。然后我们实现一个变量来引用 <code>HTMLElement</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var paragraph: HTMLElement? = HTMLElement(name: &quot;p&quot;, text: &quot;hello world&quot;)</div><div class="line">print(paragraph!.asHTML())</div></pre></td></tr></table></figure>
<p>可以看到，屏幕上打印出了<code>&lt;p&gt;hello world&lt;/p&gt;</code>字样，然后我们对变量赋值<code>nil</code>，取消引用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">paragraph = nil</div></pre></td></tr></table></figure>
<p>我们发现，并没有调用类的销毁方法，说明出现了循环引用。那么此处的循环引用是怎么出现的呢？  </p>
<p>首先说明，出现强引用的是闭包和引用实例两者，闭包其实和类相似，都是引用类型。实例<code>paragraph</code>持有闭包的引用，而闭包中又使用了<code>self</code>，因此闭包捕获了<code>self</code>，这意味着闭包又反过来持有了<code>HTMLElement</code>实例的强引用，这样两个对象就产生了循环强引用。</p>
<h3 id="解决闭包引起的循环引用"><a href="#解决闭包引起的循环引用" class="headerlink" title="解决闭包引起的循环引用"></a>解决闭包引起的循环引用</h3><p>那么如何解决呢？在Objective-C中，解决办法是外部将<code>self</code>设为<code>weak</code>类型，从而保证闭包内捕获<code>self</code>时不会发生强引用。那么在Swift中，解决的办法也类似。  </p>
<p>只不过分为弱引用和无主引用两种，和上面类似，弱引用是针对可选类型的，而无主引用是针对非可选类型的。在这个例子中，使用无主引用比较恰当。我们修改<code>HTMLElement</code>类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">class HTMLElement &#123;</div><div class="line"></div><div class="line">    let name: String</div><div class="line">    let text: String?</div><div class="line"></div><div class="line">    lazy var asHTML: Void -&gt; String = &#123;</div><div class="line">        [unowned self] in</div><div class="line">        if let text = self.text &#123;</div><div class="line">            return &quot;&lt;\(self.name)&gt;\(text)&lt;/\(self.name)&gt;&quot;</div><div class="line">        &#125;else &#123;</div><div class="line">            return &quot;&lt;\(self.name) /&gt;&quot;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    init(name: String, text: String? = nil) &#123;</div><div class="line">        self.name = name</div><div class="line">        self.text = text</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    deinit &#123;</div><div class="line">        print(&quot;HTMLElement对象被销毁&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>为了不发生循环引用，我们在闭包中使用无主引用来捕获<code>self</code>，这样将实例设为<code>nil</code>，我们发现屏幕上打印出了<code>HTMLElement对象被销毁</code>。说明我们解决问题了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这个概念并不是Swift专有，在Objective-C中就已经运用广泛。运用这种机制，能很好地跟踪和管理应用程序的内存。  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在早期，Apple一直使用的是MRC，这篇文章并不想讲解MRC，使用MRC时，Swift还没有诞生呢。MRC是手动管理内存的，比如创建一个实例对象，如果需要释放该对象，是需要手动去释放的。而使用ARC的好处是，ARC可以自动的帮您管理内存，自动释放其占有的内存。  &lt;/p&gt;
&lt;p&gt;特别注意：不管是ARC还是MRC，引用计数只仅仅应用于类的实例，不能应用于结构体和枚举类型。  &lt;/p&gt;
&lt;h3 id=&quot;自动引用计数原理&quot;&gt;&lt;a href=&quot;#自动引用计数原理&quot; class=&quot;headerlink&quot; title=&quot;自动引用计数原理&quot;&gt;&lt;/a&gt;自动引用计数原理&lt;/h3&gt;&lt;p&gt;首先记住，每创建一个新的实例，ARC会自动分配给一块内存用来存储实例的信息，当内存不再使用时，ARC会释放实例所占的内存，供其他实例使用。  &lt;/p&gt;
&lt;p&gt;为了分辨实例是否正在处于使用的情况，ARC会跟踪和计算每一个实例的引用次数，如果实例的引用次数小于1，那么ARC会销毁这个实例。  &lt;/p&gt;
&lt;p&gt;下面给出一个例子，用来解释ARC的运行机制，我们先实现一个Person类：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;class Person &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    let name: String&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    init(name: String) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        self.name = name&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        print(&amp;quot;\(name)正在被初始化&amp;quot;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    deinit &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        print(&amp;quot;\(name)正在被销毁&amp;quot;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Person类很简单，有一个名为name的属性，然后重写&lt;code&gt;init&lt;/code&gt;和&lt;code&gt;deinit&lt;/code&gt;方法。然后我们定义三个变量来对Person类进行引用：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;var person1: Person?&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;var person2: Person?&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;var person3: Person?&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;可选选项可以保证在没实例化之前是nil。  &lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;person1 = Person(name: &amp;quot;Jack&amp;quot;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;person2 = person1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;person3 = person1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;当我们对person1执行实例化时，会打印出&lt;code&gt;Jack正在被初始化&lt;/code&gt;，说明Person实例赋值给了person1，需要注意的是，两者之间是建立了一个强引用，强引用可以保证Person实例可以保持在内存中不被销毁。将同一个实例也赋值给person2和person3，又回多出两个强引用，所以现在Person实例有三个强引用。  &lt;/p&gt;
&lt;p&gt;接下来我们通过赋值&lt;code&gt;nil&lt;/code&gt;来断开强引用关系。  &lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;person1 = nil&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;person2 = nil&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后我们断开person3的强引用。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;person3 = nil&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这时我们发现，Console中打印出了&lt;code&gt;Jack正在被销毁&lt;/code&gt;的log。所以说明，当一个实例不再有强引用关系时，ARC会自动销毁存在在内存中的该实例，释放内存供其他实例使用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Swift" scheme="http://yoursite.com/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift学习之枚举、类和结构体</title>
    <link href="http://yoursite.com/2016/03/24/Swift%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%9E%9A%E4%B8%BE%E3%80%81%E7%B1%BB%E5%92%8C%E7%BB%93%E6%9E%84%E4%BD%93/"/>
    <id>http://yoursite.com/2016/03/24/Swift学习之枚举、类和结构体/</id>
    <published>2016-03-24T00:58:55.000Z</published>
    <updated>2017-07-12T08:47:15.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><blockquote>
<p>枚举是为一组相关的值定义了一个共同的类型。</p>
</blockquote>
<p>下面使用枚举表示水果的颜色：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">enum FruitsColor &#123;</div><div class="line">	case Red</div><div class="line">	case Yellow</div><div class="line">	case Green</div><div class="line">	case White</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果枚举成员没有设置原始值，其原始值将为0，依次递增1。当然，多个成员值可以出现在同一行上，用逗号隔开：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">enum FruitColor &#123;</div><div class="line">    case Red, Green, Yellow, White</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在Swift中，使用Switch可以匹配枚举值，这十分方便。我们举个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">let condition: FruitColor = .Red</div><div class="line">switch condition &#123;</div><div class="line">case .Red:</div><div class="line">    print(&quot;Red&quot;)</div><div class="line">case .Green:</div><div class="line">    print(&quot;Green&quot;)</div><div class="line">case .Yellow:</div><div class="line">    print(&quot;Yellow&quot;)</div><div class="line">default:</div><div class="line">    print(&quot;default&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>出了匹配，枚举还可以进行关联值操作，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">enum FruitProperty &#123;</div><div class="line">	case Name(String)</div><div class="line">	case Color(String)</div><div class="line">&#125;</div><div class="line"></div><div class="line">var fruit = FruitProperty(&quot;Apple&quot;)</div></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="类和结构体"><a href="#类和结构体" class="headerlink" title="类和结构体"></a>类和结构体</h3><p>在Swift中，类和结构体有很多相似之处。包括：</p>
<blockquote>
<ol>
<li>都具有属性用于存储值；</li>
<li>都提供方法实现功能；</li>
<li>都提供附属脚本用于访问值；</li>
<li>都提供构造器生成初始化值；</li>
<li>都提供扩展增加默认实现的方法；</li>
<li>都提供协议实现某种标准功能。</li>
</ol>
</blockquote>
<p>但是，类和结构体还是有些区别，比如：</p>
<blockquote>
<ol>
<li>类是允许一个类继承另一个类的特征；</li>
<li>类型转换允许在运行时检查和解释一个类实例的类型；</li>
<li>解构器允许一个类实例释放任何其所被分配的资源；</li>
<li>引用计数允许对一个类的多次引用。</li>
</ol>
</blockquote>
<p>特别注意，在结构体中，是通过被复制的方式在代码中传递的，而不是使用引用计数。  </p>
<p>语法上，两者很像。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class FruitClass &#123;</div><div class="line">    var fruitName: String?</div><div class="line">    var fruitColor: String?</div><div class="line">&#125;</div><div class="line"></div><div class="line">struct FruitStruct &#123;</div><div class="line">    var fruitName: String</div><div class="line">    var fruitColor: String</div><div class="line">&#125;</div><div class="line"></div><div class="line">let fruit = FruitClass()</div><div class="line">let fruit02 = FruitStruct(fruitName: &quot;Orange&quot;, fruitColor: &quot;Yellow&quot;)</div></pre></td></tr></table></figure>
<h4 id="有关类是引用类型的解释"><a href="#有关类是引用类型的解释" class="headerlink" title="有关类是引用类型的解释"></a>有关类是引用类型的解释</h4><p>和数值的类型不同，当类被赋予到一个变量、常量或者被传递到一个函数中时，其值不会被拷贝。引用的是已存在的实例本身而不是拷贝。  </p>
<p>我们以代码来解释：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">let fruit = FruitClass()</div><div class="line">fruit.fruitColor = &quot;Yellow&quot;</div><div class="line">fruit.fruitName = &quot;Orange&quot;</div><div class="line"></div><div class="line">let fruit02 = fruit</div><div class="line">fruit02.fruitName = &quot;Apple&quot;</div><div class="line">print(fruit.fruitName)		//Apple</div><div class="line">print(fruit02.fruitName)	//Apple</div></pre></td></tr></table></figure>
<p>由于类是引用类型，<code>fruit</code>和<code>fruit02</code>实际上引用的是FruitClass实例，它们是同一实例的两种叫法，注意，<code>fruit</code>和<code>fruit02</code>都被声明为常量而非变量，你依然可以改变color和name两个属性，是因为它们俩并不“存储”<code>FruitClass</code>实例，而只是对实例的引用。所以，改变的是被引用实例的属性值，而不是引用实例常量的值。  </p>
<p>如果判断两个常量是否引用于同一个实例，利用恒等运算符可以实现。  </p>
<blockquote>
<ul>
<li>等价于 (<code>===</code>)</li>
<li>不等价于 (<code>!==</code>)</li>
</ul>
</blockquote>
<h4 id="有关拷贝和引用"><a href="#有关拷贝和引用" class="headerlink" title="有关拷贝和引用"></a>有关拷贝和引用</h4><p>在Swift中，例如<code>String</code>、<code>Array</code>和<code>Dictionary</code>都是以结构体的形式来实现，这意味着，当发生赋值和函数穿参时，它们的值会被拷贝。  </p>
<p>而在Objective-C中，<code>NSString</code>、<code>NSArray</code>和<code>NSDictionary</code>均是以类的形式出现，并不是结构体。它们在被赋值和函数穿参时，不会发生值拷贝，而是传递当前实例的引用。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;枚举&quot;&gt;&lt;a href=&quot;#枚举&quot; class=&quot;headerlink&quot; title=&quot;枚举&quot;&gt;&lt;/a&gt;枚举&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;枚举是为一组相关的值定义了一个共同的类型。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面使用枚举表示水果的颜色：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;enum FruitsColor &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	case Red&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	case Yellow&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	case Green&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	case White&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果枚举成员没有设置原始值，其原始值将为0，依次递增1。当然，多个成员值可以出现在同一行上，用逗号隔开：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;enum FruitColor &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    case Red, Green, Yellow, White&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在Swift中，使用Switch可以匹配枚举值，这十分方便。我们举个例子：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;let condition: FruitColor = .Red&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;switch condition &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;case .Red:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    print(&amp;quot;Red&amp;quot;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;case .Green:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    print(&amp;quot;Green&amp;quot;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;case .Yellow:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    print(&amp;quot;Yellow&amp;quot;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;default:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    print(&amp;quot;default&amp;quot;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;出了匹配，枚举还可以进行关联值操作，例如：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;enum FruitProperty &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	case Name(String)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	case Color(String)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;var fruit = FruitProperty(&amp;quot;Apple&amp;quot;)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Swift" scheme="http://yoursite.com/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Hello world, Swift</title>
    <link href="http://yoursite.com/2016/03/08/Hello-world-Swift/"/>
    <id>http://yoursite.com/2016/03/08/Hello-world-Swift/</id>
    <published>2016-03-08T06:56:40.000Z</published>
    <updated>2017-07-12T08:51:15.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>这是一个充满着变化的世界，所做的每一件事，明天都可能会成为没有价值的历史。学习亦是如此，人生的选择不多。  </p>
</blockquote>
<p>满足当下，并不是一个年轻人该有的心态。拥抱Swift这个想法，其实很早就有了，只是每次都缺乏足够的耐心，最终结果未知。这次，就从一个Hello world开始，坚持下去！</p>
<h4 id="打印Hello-world"><a href="#打印Hello-world" class="headerlink" title="打印Hello world"></a>打印Hello world</h4><p>其实和C语言差不多，如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">print(&quot;Hello world&quot;)</div></pre></td></tr></table></figure>
<p>不同的是，作为一门现代编程语言，你不需要书写main方法，因为全局作用域的代码会自动当作程序的入口。还有，你再也不用写那个分号了:)</p>
<h4 id="常量和变量"><a href="#常量和变量" class="headerlink" title="常量和变量"></a>常量和变量</h4><p>在Swift中，用<code>let</code>来声明常量，用<code>var</code>来声明变量。怎么样，很简单吧，但是有时候我们需要知道常量或者变量是什么类型的，这时就需要类型标注(type annotation)，比如我们想要定义一个名为name的字符型变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var name: String</div></pre></td></tr></table></figure>
<p>冒号的意思是“是…类型”，上面这句话可以理解为“声明一个类型为String，名叫name的变量”。当然，你也可以一行定义多个：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var name, address: String</div></pre></td></tr></table></figure>
<p>注意：变量和常量的命名不能包含数学符号，箭头，非法的Unicode码，连线与制表符，也不能以数字开头。   </p>
<p>如果要打印常量或者变量，很简单(Hello world已经给出)，如果想当作占位符的方式打印，使用<code>\()</code>来完成。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">print(&quot;Your name is \(name)&quot;)</div></pre></td></tr></table></figure>
<p>上面会打印出name的值。</p>
<a id="more"></a>
<h4 id="分号"><a href="#分号" class="headerlink" title="分号"></a>分号</h4><p>Swift并不强求在每条语句结束后写<code>;</code>，但是，如果你想在同一行代码里写多条独立的语句，那必须加上<code>;</code>。</p>
<h4 id="元组-tuples"><a href="#元组-tuples" class="headerlink" title="元组(tuples)"></a>元组(tuples)</h4><p>注意，这不是数组，这是Swift独有的数据类型，类似于C语言中的结构体，用来存储一组相关的值。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let personInfo = (0001, &quot;Jack&quot;, 23)</div></pre></td></tr></table></figure>
<p>元组内的值可以是任意类型，并不要求是相同类型。上面是模拟一个人的信息，可以这样获取其中的值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">print(&quot;The number is \(personInfo.0)&quot;)</div><div class="line">print(&quot;The name is \(personInfo.1)&quot;)</div></pre></td></tr></table></figure>
<p>你还可以给单个元素命名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let personInfo = (number: 0001, name: &quot;Jack&quot;, age: 23)</div></pre></td></tr></table></figure>
<p>打印时可使用名字进行打印：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">print(&quot;The number is \(personInfo.number)&quot;)</div><div class="line">print(&quot;The name is \(personInfo.name)&quot;)</div></pre></td></tr></table></figure>
<p>在需要临时组织值时，元组会十分好用，但是如果需要复杂的数据结构，那么还是请使用类或者结构体吧。</p>
<h4 id="可选类型-optionals"><a href="#可选类型-optionals" class="headerlink" title="可选类型(optionals)"></a>可选类型(optionals)</h4><p>貌似其他语言都没有这个概念，如果学过Objective-C的话，都知道一个方法要么返回一个对象，要么返回<code>nil</code>，在OC中<code>nil</code>表示一个缺失的合法对象，然而只对对象起作用，其他免谈，相信很多人都在这块出过错，在非对象的类型中，OC的做法是返回一个特殊值来表示值缺失，如<code>NSNotFound</code>。然而，Swift大大简化了这个操作，可选类型可以表示任意类型的值缺失，而不是单单是对象。  </p>
<p>再说这个<code>nil</code>，Swift中的<code>nil</code>和Objective-C中的<code>nil</code>并不太一样，在OC中，<code>nil</code>是一个指向不存在对象的指针，而在Swift中，<code>nil</code> 不是指针，表示值缺省，是一个确定的值。任何类型的可选状态都可以被设置为<code>nil</code>，由此，<code>nil</code>是不能用于非可选的常量或者变量的。</p>
<p>对于可选类型，在判断是否有值时，使用<code>nil</code>则简单了很多，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if numberStr != nil &#123;</div><div class="line">	print(&quot;Result == \(numberStr!)&quot;)</div><div class="line">&#125;else &#123;</div><div class="line">	print(&quot;Result is nil&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个<code>!</code>叫做强制解析，表示“我就知道它有值，请使用它”。但是，使用<code>!</code>来获取一个不存在的可选值时可能会导致运行错误，所以使用前一定要确定可选值一定是非<code>nil</code>。  </p>
<p>有时候，当一个常量或变量被赋值之后，可以确定一个可选类型总会有值，这时每次都去判断可解析可选值时是非常低效的，所以出现了隐式解析可选类型，使用<code>!</code>来标识。顾名思义，它是一个自动解析的可选类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let str: String! = &quot;haha&quot;</div><div class="line">let implStr: String = str</div></pre></td></tr></table></figure>
<p>使用隐式解析后再也不需要<code>!</code>，但是注意，如果隐式解析可选类型在没有值时强制取值，会在运行时出错。所以，如果一个变量可能会成为<code>nil</code>，请不要使用隐式解析可选类型。</p>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>Swift支持大部分标准C语言的运算符，但是作为一门现代编程语言，在某些地方做了优化，下面来说说这些变化。</p>
<h4 id="浮点数求余"><a href="#浮点数求余" class="headerlink" title="浮点数求余"></a>浮点数求余</h4><p>在Swift中，可以对浮点数进行求余计算。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">8 % 2.5    //0.5</div></pre></td></tr></table></figure>
<h4 id="空合运算符-Nil-Coalescing-Operator"><a href="#空合运算符-Nil-Coalescing-Operator" class="headerlink" title="空合运算符(Nil Coalescing Operator)"></a>空合运算符(Nil Coalescing Operator)</h4><p>空合运算符可以对一个可选类型的变量进行空判断，如果包含一个值就进行解封，否则会返回一个默认值。书写方式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a ?? b</div></pre></td></tr></table></figure>
<p>注意，a必须是可选类型的，而且默认值包的类型必须和a保持一致，上面代码其实可以按照一个三目运算式来理解：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a != nil ? a! : b</div></pre></td></tr></table></figure>
<p>#####闭区间运算符<br>闭区间运算符<code>a...b</code>定义一个包含从<code>a</code>到<code>b</code>(包含<code>a</code>和<code>b</code>)的所有值区间。<code>b</code>必须大于<code>a</code>。在<code>for-in</code>中经常用到:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for index in 1...5 &#123;</div><div class="line">    print(&quot;\(index) = \(index)&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="半开区间运算符"><a href="#半开区间运算符" class="headerlink" title="半开区间运算符"></a>半开区间运算符</h4><p>半开区间运算符和闭区间运算符类似，半开区间<code>a..&lt;b</code>定义一个从<code>a</code>到<code>b</code>但不包括<code>b</code>的区间，在遍历数组中经常用到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let fruits = [&quot;apples&quot;, &quot;bananas&quot;, &quot;oranges&quot;]</div><div class="line">for i in 0..&lt;fruits.count &#123;</div><div class="line">    print(fruits[i])</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="字符串和集合类型"><a href="#字符串和集合类型" class="headerlink" title="字符串和集合类型"></a>字符串和集合类型</h3><h4 id="遍历字符串"><a href="#遍历字符串" class="headerlink" title="遍历字符串"></a>遍历字符串</h4><p>可以通过 <code>for-in</code>循环来遍历字符串中的每一个字符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for character in &quot;Hello, world!&quot;.characters &#123;</div><div class="line">	print(character)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="数组-Arrays"><a href="#数组-Arrays" class="headerlink" title="数组(Arrays)"></a>数组(Arrays)</h4><p>Swift提供<code>Arrays</code>、<code>Sets</code>和<code>Dictionaries</code>三种基本类型来存储集合数据。数组(Arrays)是有序数据的集合，集合(Sets)是无序无重复数据的集合，字典(Dictionaries)是无序的键值对的集合。</p>
<p>数组使用有序列表存储同一类型的多个值，相同的值可以出现在同一数组的不同位置。数组的创建方式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 第一种创建方式</div><div class="line">var intArr = [Int]()</div><div class="line">// 第二种创建方式, 带默认值</div><div class="line">var intArr = [Int](count: 4, repeatedValue: 0)</div><div class="line">// 第三种创建方式</div><div class="line">var intArr: [Int] = [1, 2, 3, 4]</div></pre></td></tr></table></figure>
<h4 id="集合-Sets"><a href="#集合-Sets" class="headerlink" title="集合(Sets)"></a>集合(Sets)</h4><p>集合(Sets)用来存储相同数据类型并且没有顺序的值，集合保证了在集合中每个元素只出现一次。集合的创建方式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 第一种创建方式</div><div class="line">var intSets = Set&lt;Int&gt;()</div><div class="line">// 第二种创建方式</div><div class="line">var intSets: Set&lt;Int&gt; = [1, 2, 3, 4]</div></pre></td></tr></table></figure>
<h4 id="字典-Dictionaries"><a href="#字典-Dictionaries" class="headerlink" title="字典(Dictionaries)"></a>字典(Dictionaries)</h4><p>字典是存储多个相同类型值的容器。每个值都关联着一个唯一的key，key作为字典中元素的识别符。字典中的元素是没有顺序的。字典的创建方式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 第一种创建方式</div><div class="line">var dic = [Int: String]()</div><div class="line">// 第二种创建方式</div><div class="line">var dic: [Int: String] = [1:&quot;name&quot;, 2:&quot;age&quot;, 3:&quot;address&quot;]</div></pre></td></tr></table></figure>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>在Swift中，函数的定义十分灵活，也比较好理解。下面是个简单的函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">func sayHello(personName: String) -&gt; String &#123;</div><div class="line">	let greeting = &quot;Hello, &quot; + personName + &quot;!&quot;</div><div class="line">	return greeting</div><div class="line">&#125;</div><div class="line"></div><div class="line">print(sayHello(&quot;Jack&quot;))</div></pre></td></tr></table></figure>
<h4 id="无参函数"><a href="#无参函数" class="headerlink" title="无参函数"></a>无参函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">func sayHello() -&gt; String &#123;</div><div class="line">	return &quot;Hello, world&quot;</div><div class="line">&#125;</div><div class="line"></div><div class="line">print(sayHello())</div></pre></td></tr></table></figure>
<h4 id="多参数函数"><a href="#多参数函数" class="headerlink" title="多参数函数"></a>多参数函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">func sayHello(personName: String, alreadyGreeted: Bool) -&gt; String &#123;</div><div class="line">	if alreadyGreeted &#123;</div><div class="line">		return &quot;Already greeted!&quot;</div><div class="line">	&#125;else &#123;</div><div class="line">		return &quot;Hello, &quot; + personName + &quot;!&quot;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">print(sayHello(&quot;Jack&quot;, alreadyGreeted: true))</div></pre></td></tr></table></figure>
<h4 id="无返回值函数"><a href="#无返回值函数" class="headerlink" title="无返回值函数"></a>无返回值函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">func sayHello(personName: String) &#123;</div><div class="line">	print(&quot;Hello, \(personName)!&quot;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">sayHello(&quot;Jack&quot;)</div></pre></td></tr></table></figure>
<h4 id="多重返回值函数"><a href="#多重返回值函数" class="headerlink" title="多重返回值函数"></a>多重返回值函数</h4><p>这个很实用，可以用元组来实现将多个值作为一个复合值返回。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">func findMinAndMaxFromArray(array: [Int]) -&gt; (min: Int, max: Int)? &#123;</div><div class="line">	var currentMin = array[0]</div><div class="line">	var currentMax = array[0]</div><div class="line">	for value in array[1..&lt;array.count] &#123;</div><div class="line">		if value &lt; currentMin &#123;</div><div class="line">			currentMin = value</div><div class="line">		&#125;else if value &gt; currentMax &#123;</div><div class="line">			currentMax = value</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	return (currentMin, currentMax)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面是简单的一个求最大值和最小值的函数，返回为一个元组。</p>
<h4 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h4><p>可变参数的意思是可以接受零个或者多个参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">func arithmeticMean(numbers: Double...) -&gt; Double &#123;</div><div class="line">	var total: Double = 0</div><div class="line">	for number in numbers &#123;</div><div class="line">		total += number</div><div class="line">	&#125;</div><div class="line">	return total / Double(numbers.count)</div><div class="line">&#125;</div><div class="line"></div><div class="line">arithmeticMean(1, 2, 3, 4, 5)</div><div class="line">arithmeticMean(3, 2.3, 12.3)</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这是一个充满着变化的世界，所做的每一件事，明天都可能会成为没有价值的历史。学习亦是如此，人生的选择不多。  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;满足当下，并不是一个年轻人该有的心态。拥抱Swift这个想法，其实很早就有了，只是每次都缺乏足够的耐心，最终结果未知。这次，就从一个Hello world开始，坚持下去！&lt;/p&gt;
&lt;h4 id=&quot;打印Hello-world&quot;&gt;&lt;a href=&quot;#打印Hello-world&quot; class=&quot;headerlink&quot; title=&quot;打印Hello world&quot;&gt;&lt;/a&gt;打印Hello world&lt;/h4&gt;&lt;p&gt;其实和C语言差不多，如下:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;print(&amp;quot;Hello world&amp;quot;)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;不同的是，作为一门现代编程语言，你不需要书写main方法，因为全局作用域的代码会自动当作程序的入口。还有，你再也不用写那个分号了:)&lt;/p&gt;
&lt;h4 id=&quot;常量和变量&quot;&gt;&lt;a href=&quot;#常量和变量&quot; class=&quot;headerlink&quot; title=&quot;常量和变量&quot;&gt;&lt;/a&gt;常量和变量&lt;/h4&gt;&lt;p&gt;在Swift中，用&lt;code&gt;let&lt;/code&gt;来声明常量，用&lt;code&gt;var&lt;/code&gt;来声明变量。怎么样，很简单吧，但是有时候我们需要知道常量或者变量是什么类型的，这时就需要类型标注(type annotation)，比如我们想要定义一个名为name的字符型变量：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;var name: String&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;冒号的意思是“是…类型”，上面这句话可以理解为“声明一个类型为String，名叫name的变量”。当然，你也可以一行定义多个：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;var name, address: String&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;注意：变量和常量的命名不能包含数学符号，箭头，非法的Unicode码，连线与制表符，也不能以数字开头。   &lt;/p&gt;
&lt;p&gt;如果要打印常量或者变量，很简单(Hello world已经给出)，如果想当作占位符的方式打印，使用&lt;code&gt;\()&lt;/code&gt;来完成。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;print(&amp;quot;Your name is \(name)&amp;quot;)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面会打印出name的值。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Swift" scheme="http://yoursite.com/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>玩转ProGuard</title>
    <link href="http://yoursite.com/2014/07/24/%E7%8E%A9%E8%BD%ACProGuard/"/>
    <id>http://yoursite.com/2014/07/24/玩转ProGuard/</id>
    <published>2014-07-24T13:18:11.000Z</published>
    <updated>2017-07-12T09:12:51.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>一直没有时间整理ProGuard方面的资料，今天就来将自己所学到的混淆技巧给整理一下。</p>
</blockquote>
<h3 id="ProGuard的介绍"><a href="#ProGuard的介绍" class="headerlink" title="ProGuard的介绍"></a>ProGuard的介绍</h3><p>ProGuard顾名思义，就是一个混淆器，可以删除项目中没有用到的类、字段、方法和属性，用简短而无意义的名字来重命名类、字段和方法，使得字节码最大程度的混淆、压缩和优化。</p>
<p>当然，混淆以后的包会比不混淆的包小一点，但这不是混淆的主要目的，ProGuard的最主要目的还是防止代码被反编译，逛过Android论坛的人都知道，一些不会编程的人使用一些反编译工具都可以随便破解某些apk，损害一些厂商的利益，形成恶性循环，而ProGuard的作用就是防止一些新手反编译自己的apk，看到自己应用代码层的逻辑，当然，需要注意的是，ProGuard并不是万能的，防防菜鸟还行，遇到大神一样没用，如果自己的应用特别注重反编译这块，还是试试NDK吧！</p>
<h3 id="ProGuard的使用"><a href="#ProGuard的使用" class="headerlink" title="ProGuard的使用"></a>ProGuard的使用</h3><p>由于ProGuard是针对Java语言来混淆的，不仅仅可以混淆Android代码，还可以混淆其他Java方面的代码，本文主要是针对Android代码来说的，IDE选择ADT，Android Studio其实也类似，道理都是一样的。</p>
<p>Eclipse默认已经集成了ProGuard，所以打开项目，会在根目录下看到proguard-project.txt文件，这个文件就是用来编写混淆规则的，ADT默认是不使用混淆的，如果您的应用需要混淆代码，需要在project.properties文件里取消混淆代码的注释。但是需要注意的是ADT只会在release模式下启动ProGuard，在debug模式下，为了效率并不会调用ProGuard的。  </p>
<h4 id="不能进行混淆的类"><a href="#不能进行混淆的类" class="headerlink" title="不能进行混淆的类"></a>不能进行混淆的类</h4><ul>
<li>反射用到的类；</li>
<li>AndroidManifest文件中的Activity、Service及Framework默认不会进行混淆；</li>
<li>Jni调用的类。</li>
</ul>
<h4 id="混淆生成的文件介绍"><a href="#混淆生成的文件介绍" class="headerlink" title="混淆生成的文件介绍"></a>混淆生成的文件介绍</h4><p>混淆成功后，在项目根目录下会生成一个proguard文件夹，里面有四个文件，分别是:</p>
<ul>
<li>dump.txt –&gt; 这个文件描述了apk内部所有class的内部结构；</li>
<li>mapping.txt –&gt; 这个文件非常重要，为了保险起见，记得保存，该文件描述了混淆前后代码对照表，打包后出错可以对照此表反推出出错位置；</li>
<li>seeds.txt –&gt; 这个文件列出了没有被混淆的类和成员；</li>
<li>usage.txt –&gt; 这个文件列出了被删除的代码。</li>
</ul>
<h4 id="ProGuard的常用语法"><a href="#ProGuard的常用语法" class="headerlink" title="ProGuard的常用语法"></a>ProGuard的常用语法</h4><p>ProGuard的常用语法也不多，我们举例一一举例说明。  </p>
<p>如果不想混淆第三方依赖包：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//定义外部引用的jar文件</div><div class="line">-libraryjars   libs/android-support-v4.jar</div></pre></td></tr></table></figure>
<p>不混淆某包、某类或者某个接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//不混淆com.hyyy.domain下的所有实体类</div><div class="line">-keep class  com.hyyy.domain.**  &#123;  *;  &#125;</div></pre></td></tr></table></figure>
<p>不混淆指定的方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// * 可以换成指定的方法或者类名</div><div class="line">-keepclassmembers class * &#123;</div><div class="line">   public void *(android.view.View);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不混淆指定的类和类的成员的名称</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//不混淆实现了序列化的类</div><div class="line">-keepnames class  *  implements  java.io.Serializable</div></pre></td></tr></table></figure>
<p>忽略某些类发生的警告</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//忽略com.hyyy.utils下的类发生的警告</div><div class="line">-dontwarn com.hyyy.utils.**</div></pre></td></tr></table></figure>
<p>还有一些不是经常用到的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">-ignorewarnings                     # 忽略警告，避免打包时某些警告出现  </div><div class="line">-optimizationpasses 5               # 指定代码的压缩级别  </div><div class="line">-dontusemixedcaseclassnames         # 是否使用大小写混合  </div><div class="line">-dontskipnonpubliclibraryclasses    # 是否混淆第三方jar  </div><div class="line">-dontpreverify                      # 混淆时是否做预校验  </div><div class="line">-verbose                            # 混淆时是否记录日志</div></pre></td></tr></table></figure>
<p>对了，还有针对第三方jar的混淆，这个就得根据使用什么jar包来参与混淆了，但是一般主流的第三方jar包都会给出自己jar包的混淆代码，仔细找找都会找出来的，为了防止出错，直接复制到自己的混淆代码里即可。</p>
<blockquote>
<p>使用上面的基本可以解决大多数应用混淆问题，感觉难点在第三方jar的混淆，如果混淆失败，就查看log，该keep的keep，该dontwarn的就dontwarn，也就这么回事了。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;一直没有时间整理ProGuard方面的资料，今天就来将自己所学到的混淆技巧给整理一下。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;ProGuard的介绍&quot;&gt;&lt;a href=&quot;#ProGuard的介绍&quot; class=&quot;headerlink&quot;
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>sqlite3在Android上的简单应用</title>
    <link href="http://yoursite.com/2014/07/02/sqlite3%E5%9C%A8Android%E4%B8%8A%E7%9A%84%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8/"/>
    <id>http://yoursite.com/2014/07/02/sqlite3在Android上的简单应用/</id>
    <published>2014-07-02T02:06:27.000Z</published>
    <updated>2017-07-12T09:11:01.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>sqlite数据库是一款轻量级的关系型数据库，它的运算速度快，占用内存小，特别适合移动设备上的使用。本篇文章是sqlite在android设备上的简单使用。  </p>
</blockquote>
<h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><p>sqlite创建数据库和mysql差别不大，如果您会用mysql的话，那么sqlite上手是比较容易的。新建一个MyDatabaseHelper类，具体代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">package com.example.databasetest;</div><div class="line"></div><div class="line">import android.content.Context;</div><div class="line">import android.database.sqlite.SQLiteDatabase;</div><div class="line">import android.database.sqlite.SQLiteDatabase.CursorFactory;</div><div class="line">import android.database.sqlite.SQLiteOpenHelper;</div><div class="line">import android.widget.Toast;</div><div class="line"></div><div class="line">public class MyDatabaseHelper extends SQLiteOpenHelper &#123;</div><div class="line"></div><div class="line">	public static final String CREATE_BOOK = &quot;create table Book(&quot; +</div><div class="line">			&quot;id integer primary key autoincrement,&quot; +</div><div class="line">			&quot;author text,&quot; +</div><div class="line">			&quot;price real,&quot; +</div><div class="line">			&quot;pages integer,&quot; +</div><div class="line">			&quot;name text)&quot; ;</div><div class="line"></div><div class="line">	private Context mContext ;</div><div class="line"></div><div class="line">	public MyDatabaseHelper(Context context, String name,</div><div class="line">			CursorFactory factory, int version) &#123;</div><div class="line">		super(context, name, factory, version);</div><div class="line">		mContext = context ;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void onCreate(SQLiteDatabase db) &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line">		db.execSQL(CREATE_BOOK) ;</div><div class="line">		Toast.makeText(mContext, &quot;Create succeeded&quot;, Toast.LENGTH_SHORT).show() ;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的代码意思是完成创建表的操作，我们决定点击一个按钮来完成数据库和表的创建工作，所以编写一个Button。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    xmlns:tools=&quot;http://schemas.android.com/tools&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot;</div><div class="line">    android:orientation=&quot;vertical&quot; &gt;</div><div class="line"></div><div class="line">	&lt;Button</div><div class="line">	    android:id=&quot;@+id/create_database&quot;</div><div class="line">	    android:layout_width=&quot;match_parent&quot;</div><div class="line">	    android:layout_height=&quot;wrap_content&quot;</div><div class="line">	    android:text=&quot;Create database&quot; /&gt;</div><div class="line"></div><div class="line">&lt;/LinearLayout&gt;</div></pre></td></tr></table></figure>
<p>接下来修改MainActivity，添加创建数据库和按钮事件的功能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">package com.example.databasetest;</div><div class="line"></div><div class="line">import android.app.Activity;</div><div class="line">import android.content.ContentValues;</div><div class="line">import android.database.Cursor;</div><div class="line">import android.database.sqlite.SQLiteDatabase;</div><div class="line">import android.os.Bundle;</div><div class="line">import android.util.Log;</div><div class="line">import android.view.Menu;</div><div class="line">import android.view.MenuItem;</div><div class="line">import android.view.View;</div><div class="line">import android.view.View.OnClickListener;</div><div class="line">import android.widget.Button;</div><div class="line"></div><div class="line">public class MainActivity extends Activity &#123;</div><div class="line"></div><div class="line">	private MyDatabaseHelper dbHelper ;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">		super.onCreate(savedInstanceState);</div><div class="line">		setContentView(R.layout.activity_main);</div><div class="line">		dbHelper = new MyDatabaseHelper(this, &quot;BookStore.db&quot;, null, 2) ;</div><div class="line"></div><div class="line">		Button createDatabase = (Button) findViewById(R.id.create_database) ;</div><div class="line">		createDatabase.setOnClickListener(new OnClickListener() &#123;</div><div class="line"></div><div class="line">			@Override</div><div class="line">			public void onClick(View v) &#123;</div><div class="line">				// TODO Auto-generated method stub</div><div class="line">				dbHelper.getWritableDatabase() ;</div><div class="line">			&#125;</div><div class="line">		&#125;) ;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>这时候，创建数据库和表的功能就完成了，运行应用，点击按钮，在命令行运行adb shell，查看../databases/下的文件，就会发现有一个BookStore.db文件，运行.shema命令，就可以查看建表语言了。</p>
<h3 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h3><p>增删改查是数据库的四种基本操作，添加数据使用insert()方法，我们先添一个添加数据的按钮：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;Button</div><div class="line">    android:id=&quot;@+id/add_data&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;wrap_content&quot;</div><div class="line">    android:text=&quot;Add data&quot; /&gt;</div></pre></td></tr></table></figure>
<p>然后完成点击事件的功能，修改MainActivity的onCreate()方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">//add data</div><div class="line">Button addData = (Button) findViewById(R.id.add_data) ;</div><div class="line">addData.setOnClickListener(new OnClickListener(</div><div class="line">		) &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void onClick(View v) &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line">		SQLiteDatabase db = dbHelper.getWritableDatabase() ;</div><div class="line">		ContentValues values = new ContentValues() ;</div><div class="line"></div><div class="line">		//添加第一条数据</div><div class="line">		values.put(&quot;name&quot;, &quot;The Da Vinci Code&quot;) ;</div><div class="line">		values.put(&quot;author&quot;, &quot;Dan Brown&quot;) ;</div><div class="line">		values.put(&quot;pages&quot;, 454) ;</div><div class="line">		values.put(&quot;price&quot;, 16.96) ;</div><div class="line">		db.insert(&quot;Book&quot;, null, values) ;</div><div class="line">		values.clear() ;</div><div class="line"></div><div class="line">		//添加第二条数据</div><div class="line">		values.put(&quot;name&quot;, &quot;The Lost Symbol&quot;) ;</div><div class="line">		values.put(&quot;author&quot;, &quot;Dan Brown&quot;) ;</div><div class="line">		values.put(&quot;pages&quot;, 510) ;</div><div class="line">		values.put(&quot;price&quot;, 16.95) ;</div><div class="line">		db.insert(&quot;Book&quot;, null, values) ;</div><div class="line">	&#125;</div><div class="line">&#125;) ;</div></pre></td></tr></table></figure>
<p>然后运行程序，点击添加按钮，输入select * from Book查询语句，可以看到我们刚才输入的数据了。</p>
<h3 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h3><p>更新数据与添加数据类似，我们先实现一个更新按钮：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;Button</div><div class="line">    android:id=&quot;@+id/update_data&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;wrap_content&quot;</div><div class="line">    android:text=&quot;Update data&quot; /&gt;</div></pre></td></tr></table></figure>
<p>然后修改MainActivity中的onCreate()方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">//update data</div><div class="line">Button updateData = (Button) findViewById(R.id.update_data) ;</div><div class="line">updateData.setOnClickListener(new OnClickListener() &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void onClick(View v) &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line">		SQLiteDatabase db = dbHelper.getWritableDatabase() ;</div><div class="line">		ContentValues values = new ContentValues() ;</div><div class="line">		values.put(&quot;price&quot;, 10.99) ;</div><div class="line">		db.update(&quot;Book&quot;, values, &quot;name=?&quot;, new String[]&#123;&quot;The Da Vinci Code&quot;&#125;) ;</div><div class="line">	&#125;</div><div class="line">&#125;) ;</div></pre></td></tr></table></figure>
<p>上面语句的意思是将name是The Da Vinci Code的那条数据的价格字段更新成10.99，运行程序，点击更新按钮，然后查询Book表数据，就可以看到更新了。</p>
<h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><p>删除数据也是一样的，我们先实现一个点击按钮：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;Button</div><div class="line">    android:id=&quot;@+id/delete_data&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;wrap_content&quot;</div><div class="line">    android:text=&quot;Delete data&quot; /&gt;</div></pre></td></tr></table></figure>
<p>然后修改onCreate()方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//delete data</div><div class="line">Button deleteData = (Button) findViewById(R.id.delete_data) ;</div><div class="line">deleteData.setOnClickListener(new OnClickListener() &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void onClick(View v) &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line">		SQLiteDatabase db = dbHelper.getWritableDatabase() ;</div><div class="line">		db.delete(&quot;Book&quot;, &quot;pages &gt; ?&quot;, new String[]&#123;&quot;500&quot;&#125;) ;</div><div class="line">	&#125;</div><div class="line">&#125;) ;</div></pre></td></tr></table></figure>
<p>运行程序后，查询Book表，可以发现pages大于500的那条数据被删除了。</p>
<h3 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h3><p>查询数据稍微复杂点，先实现查询按钮：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;Button</div><div class="line">    android:id=&quot;@+id/query_data&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;wrap_content&quot;</div><div class="line">    android:text=&quot;Query data&quot; /&gt;</div></pre></td></tr></table></figure>
<p>然后修改MainActivity的onCreate()方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">//query data</div><div class="line">Button queryData = (Button) findViewById(R.id.query_data) ;</div><div class="line">queryData.setOnClickListener(new OnClickListener() &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void onClick(View v) &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line">		SQLiteDatabase db = dbHelper.getWritableDatabase() ;</div><div class="line">		//查询Book表所有数据</div><div class="line">		Cursor cursor = db.query(&quot;Book&quot;, null, null, null, null, null, null) ;</div><div class="line">		if(cursor.moveToFirst())&#123;</div><div class="line">			do&#123;</div><div class="line">				//遍历Cursor对象，得到数据</div><div class="line">				String name = cursor.getString(cursor.getColumnIndex(&quot;name&quot;)) ;</div><div class="line">				String author = cursor.getString(cursor.getColumnIndex(&quot;author&quot;)) ;</div><div class="line">				int pages = cursor.getInt(cursor.getColumnIndex(&quot;pages&quot;)) ;</div><div class="line">				double price = cursor.getDouble(cursor.getColumnIndex(&quot;pages&quot;)) ;</div><div class="line"></div><div class="line">				//打印数据</div><div class="line">				Log.d(&quot;MainActivity&quot;, &quot;book name is &quot; + name) ;</div><div class="line">				Log.d(&quot;MainActivity&quot;, &quot;book author is &quot; + author) ;</div><div class="line">				Log.d(&quot;MainActivity&quot;, &quot;book pages is &quot; + pages) ;</div><div class="line">				Log.d(&quot;MainActivity&quot;, &quot;book price is &quot; + price) ;</div><div class="line">			&#125;while(cursor.moveToNext()) ;</div><div class="line">		&#125;</div><div class="line">		cursor.close() ;</div><div class="line">	&#125;</div><div class="line">&#125;) ;</div></pre></td></tr></table></figure>
<p>使用一个do..while()来实现打印数据，运行程序后，点击查询按钮，查看LogCat就可以发现打印信息了。</p>
<h3 id="利用事务实现替换数据"><a href="#利用事务实现替换数据" class="headerlink" title="利用事务实现替换数据"></a>利用事务实现替换数据</h3><p>事务的特点是保证一系列的操作要么全部完成，要么一个都不会完成，比如银行转账操作，要么转账成功，要么转账失败，不会出现你的钱被扣了，对方没接收到钱的现象。  </p>
<p>我们准备实现一个替换数据的功能，要么删除数据并添加新数据，要么什么都不操作。首先实现一个替换按钮：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;Button</div><div class="line">    android:id=&quot;@+id/replace_data&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;wrap_content&quot;</div><div class="line">    android:text=&quot;Replace data&quot; /&gt;</div></pre></td></tr></table></figure>
<p>然后修改MainActivity的onCreate()方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">//replace data</div><div class="line">Button replaceData = (Button) findViewById(R.id.replace_data) ;</div><div class="line">replaceData.setOnClickListener(new OnClickListener() &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void onClick(View v) &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line">		SQLiteDatabase db = dbHelper.getWritableDatabase() ;</div><div class="line">		db.beginTransaction() ;</div><div class="line">		try&#123;</div><div class="line">			db.delete(&quot;Book&quot;, null, null) ;</div><div class="line"></div><div class="line">			if(true)&#123;</div><div class="line">				throw new NullPointerException() ;</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			ContentValues values = new ContentValues() ;</div><div class="line">			values.put(&quot;name&quot;, &quot;Game of Thrones&quot;) ;</div><div class="line">			values.put(&quot;author&quot;, &quot;George Martin&quot;) ;</div><div class="line">			values.put(&quot;pages&quot;, 720) ;</div><div class="line">			values.put(&quot;price&quot;, 20.85) ;</div><div class="line">			db.insert(&quot;Book&quot;, null, values) ;</div><div class="line">			db.setTransactionSuccessful() ;	//事务执行成功</div><div class="line">		&#125;catch(Exception e)&#123;</div><div class="line">			e.printStackTrace() ;</div><div class="line">		&#125;finally&#123;</div><div class="line">			db.endTransaction() ;		//结束事务</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;) ;</div></pre></td></tr></table></figure>
<p>在该程序中，我们抛出了一个空指针异常，模拟操作失败，运行程序后，点击替换，你会发现数据并没有删除，但如果删除下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if(true)&#123;</div><div class="line">	throw new NullPointerException() ;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>就会发现数据被替换了。</p>
<h3 id="正确的升级数据库"><a href="#正确的升级数据库" class="headerlink" title="正确的升级数据库"></a>正确的升级数据库</h3><p>升级数据库在开发中非常常见。比如我们想新增一个Category表，修改MyDatabaseHelper类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">package com.example.databasetest;</div><div class="line"></div><div class="line">import android.content.Context;</div><div class="line">import android.database.sqlite.SQLiteDatabase;</div><div class="line">import android.database.sqlite.SQLiteDatabase.CursorFactory;</div><div class="line">import android.database.sqlite.SQLiteOpenHelper;</div><div class="line">import android.widget.Toast;</div><div class="line"></div><div class="line">public class MyDatabaseHelper extends SQLiteOpenHelper &#123;</div><div class="line"></div><div class="line">	public static final String CREATE_BOOK = &quot;create table Book(&quot; +</div><div class="line">			&quot;id integer primary key autoincrement,&quot; +</div><div class="line">			&quot;author text,&quot; +</div><div class="line">			&quot;price real,&quot; +</div><div class="line">			&quot;pages integer,&quot; +</div><div class="line">			&quot;name text)&quot; ;</div><div class="line"></div><div class="line">	public static final String CREATE_CATEGORY = &quot;create table Category(&quot; +</div><div class="line">			&quot;id integer primary key autoincrement,&quot; +</div><div class="line">			&quot;category_name text,&quot; +</div><div class="line">			&quot;category_code integer)&quot; ;</div><div class="line"></div><div class="line">	private Context mContext ;</div><div class="line"></div><div class="line">	public MyDatabaseHelper(Context context, String name,</div><div class="line">			CursorFactory factory, int version) &#123;</div><div class="line">		super(context, name, factory, version);</div><div class="line">		mContext = context ;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void onCreate(SQLiteDatabase db) &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line">		db.execSQL(CREATE_BOOK) ;</div><div class="line">		db.execSQL(CREATE_CATEGORY) ;</div><div class="line">		Toast.makeText(mContext, &quot;Create succeeded&quot;, Toast.LENGTH_SHORT).show() ;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line">		switch (oldVersion) &#123;</div><div class="line">		case 1:</div><div class="line">			db.execSQL(CREATE_CATEGORY) ;</div><div class="line">		default:</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过使用switch来判断数据库是否需要升级。如果以后数据库发生变动，只需要在switch加case就行，只将需要修改的数据库进行升级，不需要的不变。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;sqlite数据库是一款轻量级的关系型数据库，它的运算速度快，占用内存小，特别适合移动设备上的使用。本篇文章是sqlite在android设备上的简单使用。  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;创建数据库&quot;&gt;&lt;a href=&quot;#创建数据库&quot; class=&quot;headerlink&quot; title=&quot;创建数据库&quot;&gt;&lt;/a&gt;创建数据库&lt;/h3&gt;&lt;p&gt;sqlite创建数据库和mysql差别不大，如果您会用mysql的话，那么sqlite上手是比较容易的。新建一个MyDatabaseHelper类，具体代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;27&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;28&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;29&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;30&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;31&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;32&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;package com.example.databasetest;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;import android.content.Context;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;import android.database.sqlite.SQLiteDatabase;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;import android.database.sqlite.SQLiteDatabase.CursorFactory;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;import android.database.sqlite.SQLiteOpenHelper;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;import android.widget.Toast;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;public class MyDatabaseHelper extends SQLiteOpenHelper &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	public static final String CREATE_BOOK = &amp;quot;create table Book(&amp;quot; +&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;			&amp;quot;id integer primary key autoincrement,&amp;quot; +&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;			&amp;quot;author text,&amp;quot; +&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;			&amp;quot;price real,&amp;quot; +&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;			&amp;quot;pages integer,&amp;quot; +&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;			&amp;quot;name text)&amp;quot; ;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	private Context mContext ;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	public MyDatabaseHelper(Context context, String name,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;			CursorFactory factory, int version) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		super(context, name, factory, version);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		mContext = context ;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	@Override&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	public void onCreate(SQLiteDatabase db) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		// TODO Auto-generated method stub&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		db.execSQL(CREATE_BOOK) ;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		Toast.makeText(mContext, &amp;quot;Create succeeded&amp;quot;, Toast.LENGTH_SHORT).show() ;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面的代码意思是完成创建表的操作，我们决定点击一个按钮来完成数据库和表的创建工作，所以编写一个Button。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&amp;lt;LinearLayout xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    xmlns:tools=&amp;quot;http://schemas.android.com/tools&amp;quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    android:layout_width=&amp;quot;match_parent&amp;quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    android:layout_height=&amp;quot;match_parent&amp;quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    android:orientation=&amp;quot;vertical&amp;quot; &amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&amp;lt;Button&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	    android:id=&amp;quot;@+id/create_database&amp;quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	    android:layout_width=&amp;quot;match_parent&amp;quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	    android:layout_height=&amp;quot;wrap_content&amp;quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	    android:text=&amp;quot;Create database&amp;quot; /&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;lt;/LinearLayout&amp;gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;接下来修改MainActivity，添加创建数据库和按钮事件的功能。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;27&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;28&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;29&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;30&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;31&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;32&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;33&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;34&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;35&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;package com.example.databasetest;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;import android.app.Activity;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;import android.content.ContentValues;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;import android.database.Cursor;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;import android.database.sqlite.SQLiteDatabase;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;import android.os.Bundle;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;import android.util.Log;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;import android.view.Menu;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;import android.view.MenuItem;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;import android.view.View;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;import android.view.View.OnClickListener;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;import android.widget.Button;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;public class MainActivity extends Activity &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	private MyDatabaseHelper dbHelper ;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	@Override&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	protected void onCreate(Bundle savedInstanceState) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		super.onCreate(savedInstanceState);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		setContentView(R.layout.activity_main);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		dbHelper = new MyDatabaseHelper(this, &amp;quot;BookStore.db&amp;quot;, null, 2) ;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		Button createDatabase = (Button) findViewById(R.id.create_database) ;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		createDatabase.setOnClickListener(new OnClickListener() &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;			@Override&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;			public void onClick(View v) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;				// TODO Auto-generated method stub&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;				dbHelper.getWritableDatabase() ;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;			&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		&amp;#125;) ;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>SQL的基本使用</title>
    <link href="http://yoursite.com/2014/06/25/SQL%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2014/06/25/SQL语句的总结/</id>
    <published>2014-06-25T02:24:39.000Z</published>
    <updated>2017-07-12T09:10:52.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>最近在实验室做了将近一个月的数据库工作，做的都有点想吐了，来总结总结吧。</p>
</blockquote>
<h3 id="连接查询操作"><a href="#连接查询操作" class="headerlink" title="连接查询操作"></a>连接查询操作</h3><p>连接操作非常方便，它起源于笛卡尔积，笛卡尔积的大概意思就是两个对象所有的有序对的表示。  </p>
<p>首先我们先看左连接。  </p>
<p>首先连接操作就是表示出所有的有序对，左连接的操作就是在规定的条件下，以左表为准，去右表找数据，如果没有匹配到结果，就为null。这样做下去的数据数肯定大于等于左表数据数。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select * from ta left join tb on ta.id = tb.no ;</div></pre></td></tr></table></figure>
<p>需要注意的是，on后面跟的是连接两张表的字段。  </p>
<p>右连接和左连接差不多，一个意思，一般推荐使用左连接代替右连接。  </p>
<p>内连接的结果就是左右连接的交集。在实际使用中，使用内连接可以使用实现去重操作，而且还可以去掉null项，所以在上个月内连接用的还是挺多的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select * form ta inner join tb on ta.id = tb.no ;</div></pre></td></tr></table></figure>
<h3 id="group-by的妙用"><a href="#group-by的妙用" class="headerlink" title="group by的妙用"></a>group by的妙用</h3><p>总所周知，group by是进行分组操作的，但是用好它，可以解决些比较棘手的问题。  </p>
<p>比如，如何判断多个字段组合起来在表中是不是唯一的，注意，组合不是相加或者连接。如果一个字段的话，只要看它有没有重复值即可。多个字段使用order by去判断效率非常高，以两个字段为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select count(*) from ta group by a1, a2 having count(*)&gt;1 ;</div></pre></td></tr></table></figure>
<p>如果结果中有大于1的数值，则两个字段组合在这张表中不唯一。  </p>
<h3 id="防止插入重复数据"><a href="#防止插入重复数据" class="headerlink" title="防止插入重复数据"></a>防止插入重复数据</h3><p>这其实算不上什么新知识，只是有时候会分开写。一般都是先判断要插入的数据在表里面有没有，如果没有，再进行插入操作。下面的一句sql就可以实现上面的功能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">insert into ta(a1, a2) select 11, 12 from DUAL where not exists (select a1, a2 from ta where a1=11 and a2=12) ;</div></pre></td></tr></table></figure>
<p>其中使用了dual虚拟表，然后使用嵌套sql来实现判断条件。dual使用的不多，貌似是oracle中的。  </p>
<a id="more"></a>
<h3 id="查询主键字段"><a href="#查询主键字段" class="headerlink" title="查询主键字段"></a>查询主键字段</h3><p>当你遇到一个非常混乱的数据表，而且一眼也看不出它的主键是哪个字段时，或者您需要程序实现自动判断多张表的主键时，就需要下面这条语句了。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select COLUMN_KEY, COLUMN_NAME from INFORMATION_SCHEMA.COLUMNS where table_name = &apos;表名&apos; AND COLUMN_KEY=&apos;PRI&apos; ;</div></pre></td></tr></table></figure>
<p>其中COLUMN_KEY可以有四种情况。  </p>
<ol>
<li>KEY为空的，那么表示该字段可以重复，没有索引；</li>
<li>KEY是PRI，表示该字段是主键组成部分；</li>
<li>KEY是NUI，代表unique，该字段唯一，并且没有null值；</li>
<li>KEY是NUL，代表multi，该字段可以重复，可以有重复值。</li>
</ol>
<h3 id="更改存储引擎"><a href="#更改存储引擎" class="headerlink" title="更改存储引擎"></a>更改存储引擎</h3><p>mysql有很多种存储引擎，其中用的最多的是InnoDB和MyISAM这两个。有时候需要数据库实现一些新功能，比如全文检索，但是InnoDB不支持全文检索，就得将数据表存储引擎改成MyISAM。修改很简单，一条语句即可.  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alter table ta engine=myisam;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最近在实验室做了将近一个月的数据库工作，做的都有点想吐了，来总结总结吧。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;连接查询操作&quot;&gt;&lt;a href=&quot;#连接查询操作&quot; class=&quot;headerlink&quot; title=&quot;连接查询操作&quot;&gt;&lt;/a&gt;连接查询操作&lt;/h3&gt;&lt;p&gt;连接操作非常方便，它起源于笛卡尔积，笛卡尔积的大概意思就是两个对象所有的有序对的表示。  &lt;/p&gt;
&lt;p&gt;首先我们先看左连接。  &lt;/p&gt;
&lt;p&gt;首先连接操作就是表示出所有的有序对，左连接的操作就是在规定的条件下，以左表为准，去右表找数据，如果没有匹配到结果，就为null。这样做下去的数据数肯定大于等于左表数据数。  &lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;select * from ta left join tb on ta.id = tb.no ;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;需要注意的是，on后面跟的是连接两张表的字段。  &lt;/p&gt;
&lt;p&gt;右连接和左连接差不多，一个意思，一般推荐使用左连接代替右连接。  &lt;/p&gt;
&lt;p&gt;内连接的结果就是左右连接的交集。在实际使用中，使用内连接可以使用实现去重操作，而且还可以去掉null项，所以在上个月内连接用的还是挺多的。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;select * form ta inner join tb on ta.id = tb.no ;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;group-by的妙用&quot;&gt;&lt;a href=&quot;#group-by的妙用&quot; class=&quot;headerlink&quot; title=&quot;group by的妙用&quot;&gt;&lt;/a&gt;group by的妙用&lt;/h3&gt;&lt;p&gt;总所周知，group by是进行分组操作的，但是用好它，可以解决些比较棘手的问题。  &lt;/p&gt;
&lt;p&gt;比如，如何判断多个字段组合起来在表中是不是唯一的，注意，组合不是相加或者连接。如果一个字段的话，只要看它有没有重复值即可。多个字段使用order by去判断效率非常高，以两个字段为例：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;select count(*) from ta group by a1, a2 having count(*)&amp;gt;1 ;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果结果中有大于1的数值，则两个字段组合在这张表中不唯一。  &lt;/p&gt;
&lt;h3 id=&quot;防止插入重复数据&quot;&gt;&lt;a href=&quot;#防止插入重复数据&quot; class=&quot;headerlink&quot; title=&quot;防止插入重复数据&quot;&gt;&lt;/a&gt;防止插入重复数据&lt;/h3&gt;&lt;p&gt;这其实算不上什么新知识，只是有时候会分开写。一般都是先判断要插入的数据在表里面有没有，如果没有，再进行插入操作。下面的一句sql就可以实现上面的功能。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;insert into ta(a1, a2) select 11, 12 from DUAL where not exists (select a1, a2 from ta where a1=11 and a2=12) ;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;其中使用了dual虚拟表，然后使用嵌套sql来实现判断条件。dual使用的不多，貌似是oracle中的。  &lt;/p&gt;
    
    </summary>
    
    
      <category term="SQL" scheme="http://yoursite.com/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>怎样实现自动提取文章关键词</title>
    <link href="http://yoursite.com/2014/05/29/%E6%80%8E%E6%A0%B7%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E6%8F%90%E5%8F%96%E6%96%87%E7%AB%A0%E5%85%B3%E9%94%AE%E8%AF%8D/"/>
    <id>http://yoursite.com/2014/05/29/怎样实现自动提取文章关键词/</id>
    <published>2014-05-29T06:09:41.000Z</published>
    <updated>2017-07-12T09:03:30.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>有些时候，一个功能听起来好像很难实现，但是做起来其实很简单。  </p>
</blockquote>
<p>想一想，自动提取一片文章或者资料的关键词这个功能真的好厉害。实现这个应该涉及到文本分析，信息检索等多方面知识。但是，数学之美这本书告诉我们，其实运用简单的数学知识，就可以实现它。  </p>
<p>关键是我们应该怎么实现它呢？  </p>
<p>我们先假设一下，当我们拿到一篇文章后，它的关键词一般会有什么特征呢？一般来说，关键词主要是为了区分这篇文章和其他文章有什么不同，让人一眼就知道这篇文章的特点了。有的时候关键词可能是在文章中多次重复提到的那些词语。如果这样的话就很简单了，我们可以遍历整篇文章，根据文章所有词语出现的次数进行排序，排在前几位的那几个应该就是关键词了吧，  </p>
<p>但是，这样做是不是有点不对劲呀，有可能你碰到排在前几位的是一些无关紧要的词语，比如“的”，“啊”，“什么”等等。完全破坏了预期的效果。别着急，有一个非常好用的统计方法可以实现这一功能。  </p>
<a id="more"></a>
<h3 id="TF-IDF技术"><a href="#TF-IDF技术" class="headerlink" title="TF/IDF技术"></a>TF/IDF技术</h3><p>TF／IDF被公认为信息检索中最重要的发明。在搜索、文献分类和其他相关领域都有广泛的应用。  </p>
<p>通俗来讲，TF／IDF的主要解决办法就是如果某个词在一篇文章中出现的次数较多，而在其他文章中出现的次数比较少，那么这个词就有很好的区分能力，将它作为这篇文章的关键词是非常合适的。  </p>
<p>其中TF的意思是Term Frequency，即词频，指的是某个给定的词语在该文件中出现的次数。TF的值时term在文档中出现的次数除以该文档中所有term出现的总次数。比如“美食”在一篇文章中出现了10次，这篇文章中一共有100个词语，那么“美食”的TF就是10/100=0.1。  </p>
<p>IDF英文是Inverse Document Frequency。指的是逆文本频率指数，表达的是一个权重大小问题。试想一下，如果单单用词频统计关键词，然后排除掉不相关的词语，那么得到的一定是这篇文章的关键词吗？答案是不一定的。仅仅这样做，得到的有可能是一些常用的非语气词。对于一篇内容已经固定的文章，显然还需要判断这些关键词在其他文章中是不是常用的，即它们在其他文章中的TF值也很高。所以，就要使用IDF去判断一下。  </p>
<p>IDF简单来说，就是一个词语在整个文章集中出现的次数越多，那么它的IDF值越小。至于它的公式，可以参考数学之美这本书讲的。它所做的任务就是给词语一个权重，如果是比较常见的词语，那么就给它的权值比较小，如果词语比较少见，那么它的权值就比较高。  </p>
<p>然后，根据这两个，就可以简单实现功能了。  </p>
<p>下面给出功能实现的思路：  </p>
<ol>
<li>首先给文章进行分词（中文分词） ；</li>
<li>根据TF／IDF技术，得到关键词；</li>
<li>针对现实场景，可以加上不同的权重，比如，文章的话，第一段和最后一段或者标题出现的关键词权重加大。  </li>
</ol>
<p>对于一个爱好者来说，这样做已经足够了。但是，如果是专业人士的话，TF／IDF还远远不够，TF／IDF只是简单地统计设置权重，体现不出来一个词语的位置信息，而且无法看到关键词在整个文章中的分布情况。如果想进一步学习，还得多看一些这方面的paper。  </p>
<p>当然，TF／IDF的应用远不止如此。搜索引擎方面，利用它可以实现网页的相关性分析。数学之美这本书指出，如果你可以利用爬虫实现自动下载网页、建立索引，然后使用TF／IDF技术进行网页相关性分析，再加上一个衡量网页质量的PageRank算法，就可以简单地做出一个搜索引擎了，说不定你还可以做出个Google的早期模型呢。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;有些时候，一个功能听起来好像很难实现，但是做起来其实很简单。  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;想一想，自动提取一片文章或者资料的关键词这个功能真的好厉害。实现这个应该涉及到文本分析，信息检索等多方面知识。但是，数学之美这本书告诉我们，其实运用简单的数学知识，就可以实现它。  &lt;/p&gt;
&lt;p&gt;关键是我们应该怎么实现它呢？  &lt;/p&gt;
&lt;p&gt;我们先假设一下，当我们拿到一篇文章后，它的关键词一般会有什么特征呢？一般来说，关键词主要是为了区分这篇文章和其他文章有什么不同，让人一眼就知道这篇文章的特点了。有的时候关键词可能是在文章中多次重复提到的那些词语。如果这样的话就很简单了，我们可以遍历整篇文章，根据文章所有词语出现的次数进行排序，排在前几位的那几个应该就是关键词了吧，  &lt;/p&gt;
&lt;p&gt;但是，这样做是不是有点不对劲呀，有可能你碰到排在前几位的是一些无关紧要的词语，比如“的”，“啊”，“什么”等等。完全破坏了预期的效果。别着急，有一个非常好用的统计方法可以实现这一功能。  &lt;/p&gt;
    
    </summary>
    
    
      <category term="数学之美" scheme="http://yoursite.com/tags/%E6%95%B0%E5%AD%A6%E4%B9%8B%E7%BE%8E/"/>
    
  </entry>
  
  <entry>
    <title>Linux编译配置LAMP环境</title>
    <link href="http://yoursite.com/2014/04/04/Linux%E7%BC%96%E8%AF%91%E9%85%8D%E7%BD%AELAMP%E7%8E%AF%E5%A2%83/"/>
    <id>http://yoursite.com/2014/04/04/Linux编译配置LAMP环境/</id>
    <published>2014-04-04T12:32:54.000Z</published>
    <updated>2017-07-12T09:10:54.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>以前linux就只用过ubuntu系统，搭建开发环境的时候也比较简单，直接一句apt-get install就万事大吉了，并没有亲身去进行编译生成。最近需要在一台redhat上安装LAMP环境，这篇文章主要是对安装问题做些记录，防止以后再犯。  </p>
</blockquote>
<h3 id="安装前准备"><a href="#安装前准备" class="headerlink" title="安装前准备"></a>安装前准备</h3><p>本篇文章使用的redhat是enterprise 6.0版本，如果使用其他类似系统应该相差不多。首先下载好所需要的编译包，分别有:  <a href="http://httpd.apache.org/download.cgi" target="_blank" rel="external">apache2</a>、<a href="http://www.mysql.com/downloads/" target="_blank" rel="external">MySQL</a>、<a href="http://php.net/downloads.php" target="_blank" rel="external">PHP</a>。  </p>
<blockquote>
<p>注意：下载后缀为.tar.gz的就行，选择32位，还是64位。  </p>
</blockquote>
<h3 id="安装编译软件"><a href="#安装编译软件" class="headerlink" title="安装编译软件"></a>安装编译软件</h3><h4 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装MySQL</h4><p>MySQL不需要编译，只需要简单配置一些就行了。<br>首先解压下载好的MySQL安装包。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">tar zxvf mysql.tar.gz</div><div class="line">mv mysql /usr/local/mysql</div></pre></td></tr></table></figure>
<p>然后创建mysql组，新增mysql用户，并将新增用户添加到mysql组  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">groupadd mysql 建mysql组</div><div class="line">useradd -g mysql mysql 新增mysql用户，并添加到mysql组</div></pre></td></tr></table></figure>
<p>切换到mysql文件夹下，创建mysql授权表，并将目录下的文件所有属性改为root用户，将data数据目录的所有属性改为mysql用户，最后再配置一些自己所需要的设置。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">cd /usr/local/mysql</div><div class="line">scripts/mysql/mysql_install_db --user=mysql 创建mysql授权表，如果是mysql用户登录可省--user=mysql</div><div class="line"></div><div class="line">chown -R root .     当前目录下的文件的所有属性改为root用户</div><div class="line">chown -R mysql data  将data数据目录的所有属性改为mysql用户</div><div class="line">chgrp -R mysql .     将组属性改为mysql组</div><div class="line">bin/mysqld_safe --user=mysql &amp;</div><div class="line">bin/mysqladmin -u root password &apos;1qaz2wsx&apos;  设置密码</div><div class="line">cp support-files/my-medium.cnf /etc/my.cnf</div></pre></td></tr></table></figure>
<h4 id="安装apache2"><a href="#安装apache2" class="headerlink" title="安装apache2"></a>安装apache2</h4><p>首先解压apache2编译包，解压到/usr/local/apache2目录下（如果不存在请创建），然后进行编译。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">./configure --prefix=/usr/local/apache2 --with-mysql=/usr/local/mysql  --enable-cgi --enable-ssl --with-ssl=/usr/local/openssl --enable-so --enable-rewrite --enable-modules=all --enable-mods-shared=all --enable-cache --enable-disk-cache&quot; --enable-mem-cache --enable-deflate=shared</div><div class="line"></div><div class="line">make</div><div class="line"></div><div class="line">make install</div></pre></td></tr></table></figure>
<p>如果您比较幸运，执行上面语句没有出错，那么恭喜您，您安装一切顺利！然后根据自己所需设置apache开机自启动。打开/etc/rc.d/rc.local文件，添加：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/usr/local/apache/bin/apachectl start</div></pre></td></tr></table></figure>
<p>但是，并不是每个人都那么幸运，有可能你会出现下面的错误提示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cannot find mysql header files.</div></pre></td></tr></table></figure>
<p>别担心，将”–with-mysql=/usr/local/mysql”改成”–with-mysql=”试试，或者您直接查找下mysql.h文件在哪”find \ -name mysql.h”，然后将文件路径填写到=后面。  </p>
<a id="more"></a>
<p>当然，你肯定会对configure那里的语句有些困惑，那里并不是每句都要写的，也可以只写自己需要的，下面给出语句解释。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">./configure //配置源代码树</div><div class="line">--prefix=/usr/local/apache2 //Apache的安装目录。</div><div class="line">--enable-module=so //打开 so 模块，so 模块是用来提 DSO 支持的 apache 核心模块</div><div class="line">--enable-deflate=shared //支持网页压缩</div><div class="line">--enable-expires=shared //支持 HTTP 控制</div><div class="line">--enable-rewrite=shared //支持 URL 重写</div><div class="line">--enable-cache //支持缓存</div><div class="line">--enable-file-cache //支持文件缓存</div><div class="line">--enable-mem-cache //支持记忆缓存</div><div class="line">--enable-disk-cache //支持磁盘缓存</div><div class="line">--enable-static-support //支持静态连接(默认为动态连接)</div><div class="line">--enable-static-htpasswd //使用静态连接编译 htpasswd - 管理用于基本认证的用户文件</div><div class="line">--enable-static-htdigest //使用静态连接编译 htdigest - 管理用于摘要认证的用户文件</div><div class="line">--enable-static-rotatelogs //使用静态连接编译 rotatelogs - 滚动 Apache 日志的管道日志程序</div><div class="line">--enable-static-logresolve //使用静态连接编译 logresolve - 解析 Apache 日志中的IP地址为主机名</div><div class="line">--enable-static-htdbm //使用静态连接编译 htdbm - 操作 DBM 密码数据库</div><div class="line">--enable-static-ab //使用静态连接编译 ab - Apache HTTP 服务器性能测试工具</div><div class="line">--enable-static-checkgid //使用静态连接编译 checkgid</div><div class="line">--disable-cgid //禁止用一个外部 CGI 守护进程执行CGI脚本</div><div class="line">--disable-cgi //禁止编译 CGI 版本的 PHP</div><div class="line">--disable-userdir //禁止用户从自己的主目录中提供页面</div><div class="line">--with-mpm=worker // 让apache以worker方式运行</div><div class="line">--enable-authn-dbm=shared // 对动态数据库进行操作。Rewrite时需要。</div></pre></td></tr></table></figure>
<p>当然，如果哪里执行出现错误，并且你也不需要开启那个功能，别多想，直接删了它。  </p>
<h4 id="安装PHP"><a href="#安装PHP" class="headerlink" title="安装PHP"></a>安装PHP</h4><p>首先，需要解释一下为什么先安装MySQL，再安装PHP，因为如果先安装PHP，后安装MySQL，PHP无法打开MySQL扩展，以后想再次添加MySQL扩展的时候，对于新手来说，会很麻烦。  </p>
<p>所以我们先安装MySQL，再安装PHP。类似于安装apache，我们先将php压缩包解压到/usr/local/php目录下，然后打开php文件夹。执行configure操作。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">./configure --prefix=/usr/local/php  --with-apxs2=/usr/local/apache/bin/apxs --with-mysql=/usr/local/mysql --with-mysqli= --enable-mbstring--enable-gd-native-ttf --enable-gd-jis-conv --enable-ftp  --enable-soap --enable-sockets  --enable-force-cgi-redirect --enable-inline-optimization --disable-debug  --enable-calendar</div><div class="line"></div><div class="line">make</div><div class="line"></div><div class="line">make install</div></pre></td></tr></table></figure>
<p>和上面一样，你可能只需要其中的一部分命令，所以根据自己所需，删除一些你不需要的命令。但是，这里我想建议，如果您准备使用<a href="http://www.phpmyadmin.net/home_page/index.php" target="_blank" rel="external">phpmyadmin</a>来访问你的数据库，下面几条命令尽量还是写上，不然到时候后悔莫及。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">--with-apxs2=   //表示将PHP编译安装称apache的模块，指定apache的apxs文件的位置</div><div class="line">--with-mysql= //编译的时候自动编译访问mysql的驱动，指定mysql的安装位置  </div><div class="line">--with-mysqli= //指定mysql接口话的访问的配置文件的位置</div><div class="line">--enable-mbstring  //打开mbstring扩展</div><div class="line">--enable-json  //打开json扩展</div></pre></td></tr></table></figure>
<p>上面就是我搭建LAMP环境的过程，作为新手，第一次遇到这样的问题非常苦恼，希望遇到此问题的其他同仁，不要灰心，沉下心来就能解决问题。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;以前linux就只用过ubuntu系统，搭建开发环境的时候也比较简单，直接一句apt-get install就万事大吉了，并没有亲身去进行编译生成。最近需要在一台redhat上安装LAMP环境，这篇文章主要是对安装问题做些记录，防止以后再犯。  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;安装前准备&quot;&gt;&lt;a href=&quot;#安装前准备&quot; class=&quot;headerlink&quot; title=&quot;安装前准备&quot;&gt;&lt;/a&gt;安装前准备&lt;/h3&gt;&lt;p&gt;本篇文章使用的redhat是enterprise 6.0版本，如果使用其他类似系统应该相差不多。首先下载好所需要的编译包，分别有:  &lt;a href=&quot;http://httpd.apache.org/download.cgi&quot;&gt;apache2&lt;/a&gt;、&lt;a href=&quot;http://www.mysql.com/downloads/&quot;&gt;MySQL&lt;/a&gt;、&lt;a href=&quot;http://php.net/downloads.php&quot;&gt;PHP&lt;/a&gt;。  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：下载后缀为.tar.gz的就行，选择32位，还是64位。  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;安装编译软件&quot;&gt;&lt;a href=&quot;#安装编译软件&quot; class=&quot;headerlink&quot; title=&quot;安装编译软件&quot;&gt;&lt;/a&gt;安装编译软件&lt;/h3&gt;&lt;h4 id=&quot;安装MySQL&quot;&gt;&lt;a href=&quot;#安装MySQL&quot; class=&quot;headerlink&quot; title=&quot;安装MySQL&quot;&gt;&lt;/a&gt;安装MySQL&lt;/h4&gt;&lt;p&gt;MySQL不需要编译，只需要简单配置一些就行了。&lt;br&gt;首先解压下载好的MySQL安装包。  &lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;tar zxvf mysql.tar.gz&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;mv mysql /usr/local/mysql&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后创建mysql组，新增mysql用户，并将新增用户添加到mysql组  &lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;groupadd mysql 建mysql组&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;useradd -g mysql mysql 新增mysql用户，并添加到mysql组&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;切换到mysql文件夹下，创建mysql授权表，并将目录下的文件所有属性改为root用户，将data数据目录的所有属性改为mysql用户，最后再配置一些自己所需要的设置。  &lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;cd /usr/local/mysql&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;scripts/mysql/mysql_install_db --user=mysql 创建mysql授权表，如果是mysql用户登录可省--user=mysql&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;chown -R root .     当前目录下的文件的所有属性改为root用户&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;chown -R mysql data  将data数据目录的所有属性改为mysql用户&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;chgrp -R mysql .     将组属性改为mysql组&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;bin/mysqld_safe --user=mysql &amp;amp;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;bin/mysqladmin -u root password &amp;apos;1qaz2wsx&amp;apos;  设置密码&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;cp support-files/my-medium.cnf /etc/my.cnf&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;安装apache2&quot;&gt;&lt;a href=&quot;#安装apache2&quot; class=&quot;headerlink&quot; title=&quot;安装apache2&quot;&gt;&lt;/a&gt;安装apache2&lt;/h4&gt;&lt;p&gt;首先解压apache2编译包，解压到/usr/local/apache2目录下（如果不存在请创建），然后进行编译。  &lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;./configure --prefix=/usr/local/apache2 --with-mysql=/usr/local/mysql  --enable-cgi --enable-ssl --with-ssl=/usr/local/openssl --enable-so --enable-rewrite --enable-modules=all --enable-mods-shared=all --enable-cache --enable-disk-cache&amp;quot; --enable-mem-cache --enable-deflate=shared&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;make&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;make install&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果您比较幸运，执行上面语句没有出错，那么恭喜您，您安装一切顺利！然后根据自己所需设置apache开机自启动。打开/etc/rc.d/rc.local文件，添加：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;/usr/local/apache/bin/apachectl start&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;但是，并不是每个人都那么幸运，有可能你会出现下面的错误提示：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;cannot find mysql header files.&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;别担心，将”–with-mysql=/usr/local/mysql”改成”–with-mysql=”试试，或者您直接查找下mysql.h文件在哪”find \ -name mysql.h”，然后将文件路径填写到=后面。  &lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
</feed>
